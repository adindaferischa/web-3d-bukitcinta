{"mappings":"AGyeO,SAAS,IACZ,MAAO,cAAe,QAAU,OAAO,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,2GACrE,CA3eY,KAAZ,GAAA,GFaiB,IEieN,AAAe,OAAf,KAAuB,AAAyB,KAAA,IAAzB,SAAS,WAAW,EAAkB,iBAAkB,QAAU,sBAAuB,QAAU,UAAU,gBAAgB,CF/dlJ,SAAS,oBAAoB,CAAC,OAAO,CAAC,EAAE,CAErD,MAAM,EAAW,CACb,SAAU,aACV,SAAU,KACV,KAAM,QACN,MAAO,QACP,YAAa,CAAA,EACb,QAAS,KACT,eAAgB,CAAA,EAChB,gBAAiB,CAAA,EACjB,aAAc,SACd,MAAO,QACP,OAAQ,QACR,YAAa,QACb,kBAAmB,KACnB,iBAAkB,KAClB,gBAAiB,KACjB,eAAgB,KAChB,cAAe,KACf,aAAc,KACd,qBAAsB,KACtB,OAAQ,KACR,QAAS,KACT,KAAM,CAAA,EACN,SAAU,CAAA,EACV,UAAW,CAAA,EACX,aAAc,CAAA,EACd,eAAgB,GAChB,eAAgB,GAChB,QAAS,CAAA,EACT,gBAAiB,CAAA,EACjB,gBAAiB,CAAA,EACjB,gBAAiB,CAAA,EACjB,mBAAoB,CAAA,EACpB,oBAAqB,CAAA,EACrB,QAAS,CAAA,EACT,KAAM,CACF,IAAK,sCACL,GAAI,qCACJ,OAAQ,CACJ,MAAO,OACP,WAAY,CAAE,QAAS,CAAA,EAAM,UAAW,CAAA,CAAK,EAC7C,QAAS,CACL,SAAU,CAAA,EACV,IAAK,EACL,SAAU,EACV,eAAgB,CACpB,EACA,MAAO,CACH,OAAQ,CAAA,EACR,SAAU,CAAA,EACV,MAAO,CAAA,EACP,YAAa,CAAA,CACjB,CACJ,CACJ,EACA,WAAY,OACZ,YAAa,OACb,YAAa,QACb,SAAU,WACV,WAAY,GACZ,UAAW,CACP,KAAM,CAAE,GAAI,SAAU,IAAK,SAAU,EACrC,KAAM,CAAE,GAAI,SAAU,IAAK,SAAU,EACrC,MAAO,CAAE,GAAI,eAAgB,IAAK,cAAe,EACjD,UAAW,CAAE,GAAI,cAAe,IAAK,eAAgB,EACrD,KAAM,CAAE,GAAI,OAAQ,IAAK,MAAO,CACpC,EACA,IAAK,CACD,MAAO,ypBACP,KAAM,iZACN,KAAM,iXACV,CACJ,CASA,CAAA,EAAS,SAAS,CAAG,CAAC;;;;;;;;;;;;;MAahB,CAAC,CAEP,EAAS,YAAY,CAAG,CAAC;;;;;;;;;MASnB,CAAC","sources":["<anon>","src/assets/vendor/glightbox/src/js/glightbox.js","src/assets/vendor/glightbox/src/js/core/keyboard-navigation.js","src/assets/vendor/glightbox/src/js/utils/helpers.js","src/assets/vendor/glightbox/src/js/core/slide.js","src/assets/vendor/glightbox/src/js/core/zoom.js","src/assets/vendor/glightbox/src/js/core/drag.js","src/assets/vendor/glightbox/src/js/slides/image.js","src/assets/vendor/glightbox/src/js/slides/video.js","src/assets/vendor/glightbox/src/js/slides/inline.js","src/assets/vendor/glightbox/src/js/slides/iframe.js","src/assets/vendor/glightbox/src/js/core/slide-parser.js","src/assets/vendor/glightbox/src/js/core/touch-navigation.js","src/assets/vendor/glightbox/src/js/core/touch-events.js"],"sourcesContent":["/**\n * GLightbox\n * Awesome pure javascript lightbox\n * made by https://www.biati.digital\n * Github: https://github.com/biati-digital/glightbox\n */ /**\n * Keyboard Navigation\n * Allow navigation using the keyboard\n *\n * @param {object} instance\n */ const $d8642219fb19b896$var$uid = Date.now();\nfunction $d8642219fb19b896$export$8b58be045bf06082() {\n    let extended = {};\n    let deep = true;\n    let i = 0;\n    let length = arguments.length;\n    if (Object.prototype.toString.call(arguments[0]) === \"[object Boolean]\") {\n        deep = arguments[0];\n        i++;\n    }\n    let merge = (obj)=>{\n        for(let prop in obj)if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n            if (deep && Object.prototype.toString.call(obj[prop]) === \"[object Object]\") extended[prop] = $d8642219fb19b896$export$8b58be045bf06082(true, extended[prop], obj[prop]);\n            else extended[prop] = obj[prop];\n        }\n    };\n    for(; i < length; i++){\n        let obj = arguments[i];\n        merge(obj);\n    }\n    return extended;\n}\nfunction $d8642219fb19b896$export$79b2f7037acddd43(collection, callback) {\n    if ($d8642219fb19b896$export$8ee0fc9ee280b4ee(collection) || collection === window || collection === document) collection = [\n        collection\n    ];\n    if (!$d8642219fb19b896$export$1e2f57719e155213(collection) && !$d8642219fb19b896$export$a6cdc56e425d0d0a(collection)) collection = [\n        collection\n    ];\n    if ($d8642219fb19b896$export$346677f925de839c(collection) == 0) return;\n    if ($d8642219fb19b896$export$1e2f57719e155213(collection) && !$d8642219fb19b896$export$a6cdc56e425d0d0a(collection)) {\n        let l = collection.length, i = 0;\n        for(; i < l; i++){\n            if (callback.call(collection[i], collection[i], i, collection) === false) break;\n        }\n    } else if ($d8642219fb19b896$export$a6cdc56e425d0d0a(collection)) {\n        for(let key in collection)if ($d8642219fb19b896$export$a4f4bb6b1453fff5(collection, key)) {\n            if (callback.call(collection[key], collection[key], key, collection) === false) break;\n        }\n    }\n}\nfunction $d8642219fb19b896$export$7795e1c7e49924dd(node, name = null, fn = null) {\n    const cache = node[$d8642219fb19b896$var$uid] = node[$d8642219fb19b896$var$uid] || [];\n    const data = {\n        all: cache,\n        evt: null,\n        found: null\n    };\n    if (name && fn && $d8642219fb19b896$export$346677f925de839c(cache) > 0) $d8642219fb19b896$export$79b2f7037acddd43(cache, (cl, i)=>{\n        if (cl.eventName == name && cl.fn.toString() == fn.toString()) {\n            data.found = true;\n            data.evt = i;\n            return false;\n        }\n    });\n    return data;\n}\nfunction $d8642219fb19b896$export$f531f92e2a15358f(eventName, { onElement: onElement, withCallback: withCallback, avoidDuplicate: avoidDuplicate = true, once: once = false, useCapture: useCapture = false } = {}, thisArg) {\n    let element = onElement || [];\n    if ($d8642219fb19b896$export$844ec244b1367d54(element)) element = document.querySelectorAll(element);\n    function handler(event) {\n        if ($d8642219fb19b896$export$f6e2535fb5126e54(withCallback)) withCallback.call(thisArg, event, this);\n        if (once) handler.destroy();\n    }\n    handler.destroy = function() {\n        $d8642219fb19b896$export$79b2f7037acddd43(element, (el)=>{\n            const events = $d8642219fb19b896$export$7795e1c7e49924dd(el, eventName, handler);\n            if (events.found) events.all.splice(events.evt, 1);\n            if (el.removeEventListener) el.removeEventListener(eventName, handler, useCapture);\n        });\n    };\n    $d8642219fb19b896$export$79b2f7037acddd43(element, (el)=>{\n        const events = $d8642219fb19b896$export$7795e1c7e49924dd(el, eventName, handler);\n        if (el.addEventListener && avoidDuplicate && !events.found || !avoidDuplicate) {\n            el.addEventListener(eventName, handler, useCapture);\n            events.all.push({\n                eventName: eventName,\n                fn: handler\n            });\n        }\n    });\n    return handler;\n}\nfunction $d8642219fb19b896$export$d2cf6cd1dc7067d3(node, name) {\n    $d8642219fb19b896$export$79b2f7037acddd43(name.split(\" \"), (cl)=>node.classList.add(cl));\n}\nfunction $d8642219fb19b896$export$c2255604a80b4506(node, name) {\n    $d8642219fb19b896$export$79b2f7037acddd43(name.split(\" \"), (cl)=>node.classList.remove(cl));\n}\nfunction $d8642219fb19b896$export$4ea3d958472af68f(node, name) {\n    return node.classList.contains(name);\n}\nfunction $d8642219fb19b896$export$ff7f7c97cdce86e(elem, selector) {\n    while(elem !== document.body){\n        elem = elem.parentElement;\n        if (!elem) return false;\n        const matches = typeof elem.matches == \"function\" ? elem.matches(selector) : elem.msMatchesSelector(selector);\n        if (matches) return elem;\n    }\n}\nfunction $d8642219fb19b896$export$5ed9d0a3cf9b0f86(element, animation = \"\", callback = false) {\n    if (!element || animation === \"\") return false;\n    if (animation === \"none\") {\n        if ($d8642219fb19b896$export$f6e2535fb5126e54(callback)) callback();\n        return false;\n    }\n    const animationEnd = $d8642219fb19b896$export$f959a73baa0302ec();\n    const animationNames = animation.split(\" \");\n    $d8642219fb19b896$export$79b2f7037acddd43(animationNames, (name)=>{\n        $d8642219fb19b896$export$d2cf6cd1dc7067d3(element, \"g\" + name);\n    });\n    $d8642219fb19b896$export$f531f92e2a15358f(animationEnd, {\n        onElement: element,\n        avoidDuplicate: false,\n        once: true,\n        withCallback: (event, target)=>{\n            $d8642219fb19b896$export$79b2f7037acddd43(animationNames, (name)=>{\n                $d8642219fb19b896$export$c2255604a80b4506(target, \"g\" + name);\n            });\n            if ($d8642219fb19b896$export$f6e2535fb5126e54(callback)) callback();\n        }\n    });\n}\nfunction $d8642219fb19b896$export$fd43050ca342497c(node, translate = \"\") {\n    if (translate === \"\") {\n        node.style.webkitTransform = \"\";\n        node.style.MozTransform = \"\";\n        node.style.msTransform = \"\";\n        node.style.OTransform = \"\";\n        node.style.transform = \"\";\n        return false;\n    }\n    node.style.webkitTransform = translate;\n    node.style.MozTransform = translate;\n    node.style.msTransform = translate;\n    node.style.OTransform = translate;\n    node.style.transform = translate;\n}\nfunction $d8642219fb19b896$export$57bf213be019eeb0(element) {\n    element.style.display = \"block\";\n}\nfunction $d8642219fb19b896$export$fe8985bb6374093c(element) {\n    element.style.display = \"none\";\n}\nfunction $d8642219fb19b896$export$8062c7bb2dbf069a(htmlStr) {\n    let frag = document.createDocumentFragment(), temp = document.createElement(\"div\");\n    temp.innerHTML = htmlStr;\n    while(temp.firstChild)frag.appendChild(temp.firstChild);\n    return frag;\n}\nfunction $d8642219fb19b896$export$994b0103697d2bf() {\n    return {\n        width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,\n        height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight\n    };\n}\nfunction $d8642219fb19b896$export$f959a73baa0302ec() {\n    let t, el = document.createElement(\"fakeelement\");\n    let animations = {\n        animation: \"animationend\",\n        OAnimation: \"oAnimationEnd\",\n        MozAnimation: \"animationend\",\n        WebkitAnimation: \"webkitAnimationEnd\"\n    };\n    for(t in animations){\n        if (el.style[t] !== undefined) return animations[t];\n    }\n}\nfunction $d8642219fb19b896$export$bd36fba2d672470e() {\n    let t, el = document.createElement(\"fakeelement\");\n    const transitions = {\n        transition: \"transitionend\",\n        OTransition: \"oTransitionEnd\",\n        MozTransition: \"transitionend\",\n        WebkitTransition: \"webkitTransitionEnd\"\n    };\n    for(t in transitions){\n        if (el.style[t] !== undefined) return transitions[t];\n    }\n}\nfunction $d8642219fb19b896$export$eca25244f8f7df8e(config) {\n    let { url: url, allow: allow, callback: callback, appendTo: appendTo } = config;\n    let iframe = document.createElement(\"iframe\");\n    iframe.className = \"vimeo-video gvideo\";\n    iframe.src = url;\n    iframe.style.width = \"100%\";\n    iframe.style.height = \"100%\";\n    if (allow) iframe.setAttribute(\"allow\", allow);\n    iframe.onload = function() {\n        iframe.onload = null;\n        $d8642219fb19b896$export$d2cf6cd1dc7067d3(iframe, \"node-ready\");\n        if ($d8642219fb19b896$export$f6e2535fb5126e54(callback)) callback();\n    };\n    if (appendTo) appendTo.appendChild(iframe);\n    return iframe;\n}\nfunction $d8642219fb19b896$export$4e57ed416e50788e(check, onComplete, delay, timeout) {\n    if (check()) {\n        onComplete();\n        return;\n    }\n    if (!delay) delay = 100;\n    let timeoutPointer;\n    let intervalPointer = setInterval(()=>{\n        if (!check()) return;\n        clearInterval(intervalPointer);\n        if (timeoutPointer) clearTimeout(timeoutPointer);\n        onComplete();\n    }, delay);\n    if (timeout) timeoutPointer = setTimeout(()=>{\n        clearInterval(intervalPointer);\n    }, timeout);\n}\nfunction $d8642219fb19b896$export$27546899234f31f(url, waitFor, callback) {\n    if ($d8642219fb19b896$export$984f70f9382f5d27(url)) {\n        console.error(\"Inject assets error\");\n        return;\n    }\n    if ($d8642219fb19b896$export$f6e2535fb5126e54(waitFor)) {\n        callback = waitFor;\n        waitFor = false;\n    }\n    if ($d8642219fb19b896$export$844ec244b1367d54(waitFor) && waitFor in window) {\n        if ($d8642219fb19b896$export$f6e2535fb5126e54(callback)) callback();\n        return;\n    }\n    let found;\n    if (url.indexOf(\".css\") !== -1) {\n        found = document.querySelectorAll('link[href=\"' + url + '\"]');\n        if (found && found.length > 0) {\n            if ($d8642219fb19b896$export$f6e2535fb5126e54(callback)) callback();\n            return;\n        }\n        const head = document.getElementsByTagName(\"head\")[0];\n        const headStyles = head.querySelectorAll('link[rel=\"stylesheet\"]');\n        const link = document.createElement(\"link\");\n        link.rel = \"stylesheet\";\n        link.type = \"text/css\";\n        link.href = url;\n        link.media = \"all\";\n        if (headStyles) head.insertBefore(link, headStyles[0]);\n        else head.appendChild(link);\n        if ($d8642219fb19b896$export$f6e2535fb5126e54(callback)) callback();\n        return;\n    }\n    found = document.querySelectorAll('script[src=\"' + url + '\"]');\n    if (found && found.length > 0) {\n        if ($d8642219fb19b896$export$f6e2535fb5126e54(callback)) {\n            if ($d8642219fb19b896$export$844ec244b1367d54(waitFor)) {\n                $d8642219fb19b896$export$4e57ed416e50788e(()=>{\n                    return typeof window[waitFor] !== \"undefined\";\n                }, ()=>{\n                    callback();\n                });\n                return false;\n            }\n            callback();\n        }\n        return;\n    }\n    let script = document.createElement(\"script\");\n    script.type = \"text/javascript\";\n    script.src = url;\n    script.onload = ()=>{\n        if ($d8642219fb19b896$export$f6e2535fb5126e54(callback)) {\n            if ($d8642219fb19b896$export$844ec244b1367d54(waitFor)) {\n                $d8642219fb19b896$export$4e57ed416e50788e(()=>{\n                    return typeof window[waitFor] !== \"undefined\";\n                }, ()=>{\n                    callback();\n                });\n                return false;\n            }\n            callback();\n        }\n    };\n    document.body.appendChild(script);\n}\nfunction $d8642219fb19b896$export$d0a8044dce8ff2fc() {\n    return \"navigator\" in window && window.navigator.userAgent.match(/(iPad)|(iPhone)|(iPod)|(Android)|(PlayBook)|(BB10)|(BlackBerry)|(Opera Mini)|(IEMobile)|(webOS)|(MeeGo)/i);\n}\nfunction $d8642219fb19b896$export$971e5333ff27c622() {\n    return $d8642219fb19b896$export$d0a8044dce8ff2fc() !== null || document.createTouch !== undefined || \"ontouchstart\" in window || \"onmsgesturechange\" in window || navigator.msMaxTouchPoints;\n}\nfunction $d8642219fb19b896$export$f6e2535fb5126e54(f) {\n    return typeof f === \"function\";\n}\nfunction $d8642219fb19b896$export$844ec244b1367d54(s) {\n    return typeof s === \"string\";\n}\nfunction $d8642219fb19b896$export$8ee0fc9ee280b4ee(el) {\n    return !!(el && el.nodeType && el.nodeType == 1);\n}\nfunction $d8642219fb19b896$export$43bee75e5e14138e(ar) {\n    return Array.isArray(ar);\n}\nfunction $d8642219fb19b896$export$1e2f57719e155213(ar) {\n    return ar && ar.length && isFinite(ar.length);\n}\nfunction $d8642219fb19b896$export$a6cdc56e425d0d0a(o) {\n    let type = typeof o;\n    return type === \"object\" && o != null && !$d8642219fb19b896$export$f6e2535fb5126e54(o) && !$d8642219fb19b896$export$43bee75e5e14138e(o);\n}\nfunction $d8642219fb19b896$export$984f70f9382f5d27(o) {\n    return o == null;\n}\nfunction $d8642219fb19b896$export$a4f4bb6b1453fff5(obj, key) {\n    return obj !== null && hasOwnProperty.call(obj, key);\n}\nfunction $d8642219fb19b896$export$346677f925de839c(o) {\n    if ($d8642219fb19b896$export$a6cdc56e425d0d0a(o)) {\n        if (o.keys) return o.keys().length;\n        let l = 0;\n        for(let k in o)if ($d8642219fb19b896$export$a4f4bb6b1453fff5(o, k)) l++;\n        return l;\n    } else return o.length;\n}\nfunction $d8642219fb19b896$export$7e4aa119212bc614(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n\nfunction $7eef44a6201db4db$var$getNextFocusElement(current = -1) {\n    const btns = document.querySelectorAll(\".gbtn[data-taborder]:not(.disabled)\");\n    if (!btns.length) return false;\n    if (btns.length == 1) return btns[0];\n    if (typeof current == \"string\") current = parseInt(current);\n    const orders = [];\n    (0, $d8642219fb19b896$export$79b2f7037acddd43)(btns, (btn)=>{\n        orders.push(btn.getAttribute(\"data-taborder\"));\n    });\n    const highestOrder = Math.max.apply(Math, orders.map((order)=>parseInt(order)));\n    let newIndex = current < 0 ? 1 : current + 1;\n    if (newIndex > highestOrder) newIndex = \"1\";\n    const nextOrders = orders.filter((el)=>el >= parseInt(newIndex));\n    const nextFocus = nextOrders.sort()[0];\n    return document.querySelector(`.gbtn[data-taborder=\"${nextFocus}\"]`);\n}\nfunction $7eef44a6201db4db$export$2e2bcd8739ae039(instance) {\n    if (instance.events.hasOwnProperty(\"keyboard\")) return false;\n    instance.events[\"keyboard\"] = (0, $d8642219fb19b896$export$f531f92e2a15358f)(\"keydown\", {\n        onElement: window,\n        withCallback: (event, target)=>{\n            event = event || window.event;\n            const key = event.keyCode;\n            if (key == 9) {\n                //prettier-ignore\n                const focusedButton = document.querySelector(\".gbtn.focused\");\n                if (!focusedButton) {\n                    const activeElement = document.activeElement && document.activeElement.nodeName ? document.activeElement.nodeName.toLocaleLowerCase() : false;\n                    if (activeElement == \"input\" || activeElement == \"textarea\" || activeElement == \"button\") return;\n                }\n                event.preventDefault();\n                const btns = document.querySelectorAll(\".gbtn[data-taborder]\");\n                if (!btns || btns.length <= 0) return;\n                if (!focusedButton) {\n                    const first = $7eef44a6201db4db$var$getNextFocusElement();\n                    if (first) {\n                        first.focus();\n                        (0, $d8642219fb19b896$export$d2cf6cd1dc7067d3)(first, \"focused\");\n                    }\n                    return;\n                }\n                let currentFocusOrder = focusedButton.getAttribute(\"data-taborder\");\n                let nextFocus = $7eef44a6201db4db$var$getNextFocusElement(currentFocusOrder);\n                (0, $d8642219fb19b896$export$c2255604a80b4506)(focusedButton, \"focused\");\n                if (nextFocus) {\n                    nextFocus.focus();\n                    (0, $d8642219fb19b896$export$d2cf6cd1dc7067d3)(nextFocus, \"focused\");\n                }\n            }\n            if (key == 39) instance.nextSlide();\n            if (key == 37) instance.prevSlide();\n            if (key == 27) instance.close();\n        }\n    });\n}\n\n\n/**\n * Slide\n * class to hablde slide creation\n * and config parser\n */ /**\n * ZoomImages\n * Allow imaes to zoom and drag\n * for desktops\n *\n * @param {node} img node\n * @param {node} slide container\n * @param {function} function to trigger on close\n */ class $0bb52a7e29744ad2$export$2e2bcd8739ae039 {\n    constructor(el, slide, onclose = null){\n        this.img = el;\n        this.slide = slide;\n        this.onclose = onclose;\n        if (this.img.setZoomEvents) return false;\n        this.active = false;\n        this.zoomedIn = false;\n        this.dragging = false;\n        this.currentX = null;\n        this.currentY = null;\n        this.initialX = null;\n        this.initialY = null;\n        this.xOffset = 0;\n        this.yOffset = 0;\n        this.img.addEventListener(\"mousedown\", (e)=>this.dragStart(e), false);\n        this.img.addEventListener(\"mouseup\", (e)=>this.dragEnd(e), false);\n        this.img.addEventListener(\"mousemove\", (e)=>this.drag(e), false);\n        this.img.addEventListener(\"click\", (e)=>{\n            if (this.slide.classList.contains(\"dragging-nav\")) {\n                this.zoomOut();\n                return false;\n            }\n            if (!this.zoomedIn) return this.zoomIn();\n            if (this.zoomedIn && !this.dragging) this.zoomOut();\n        }, false);\n        this.img.setZoomEvents = true;\n    }\n    zoomIn() {\n        let winWidth = this.widowWidth();\n        if (this.zoomedIn || winWidth <= 768) return;\n        const img = this.img;\n        img.setAttribute(\"data-style\", img.getAttribute(\"style\"));\n        img.style.maxWidth = img.naturalWidth + \"px\";\n        img.style.maxHeight = img.naturalHeight + \"px\";\n        if (img.naturalWidth > winWidth) {\n            let centerX = winWidth / 2 - img.naturalWidth / 2;\n            this.setTranslate(this.img.parentNode, centerX, 0);\n        }\n        this.slide.classList.add(\"zoomed\");\n        this.zoomedIn = true;\n    }\n    zoomOut() {\n        this.img.parentNode.setAttribute(\"style\", \"\");\n        this.img.setAttribute(\"style\", this.img.getAttribute(\"data-style\"));\n        this.slide.classList.remove(\"zoomed\");\n        this.zoomedIn = false;\n        this.currentX = null;\n        this.currentY = null;\n        this.initialX = null;\n        this.initialY = null;\n        this.xOffset = 0;\n        this.yOffset = 0;\n        if (this.onclose && typeof this.onclose == \"function\") this.onclose();\n    }\n    dragStart(e) {\n        e.preventDefault();\n        if (!this.zoomedIn) {\n            this.active = false;\n            return;\n        }\n        if (e.type === \"touchstart\") {\n            this.initialX = e.touches[0].clientX - this.xOffset;\n            this.initialY = e.touches[0].clientY - this.yOffset;\n        } else {\n            this.initialX = e.clientX - this.xOffset;\n            this.initialY = e.clientY - this.yOffset;\n        }\n        if (e.target === this.img) {\n            this.active = true;\n            this.img.classList.add(\"dragging\");\n        }\n    }\n    dragEnd(e) {\n        e.preventDefault();\n        this.initialX = this.currentX;\n        this.initialY = this.currentY;\n        this.active = false;\n        setTimeout(()=>{\n            this.dragging = false;\n            this.img.isDragging = false;\n            this.img.classList.remove(\"dragging\");\n        }, 100);\n    }\n    drag(e) {\n        if (this.active) {\n            e.preventDefault();\n            if (e.type === \"touchmove\") {\n                this.currentX = e.touches[0].clientX - this.initialX;\n                this.currentY = e.touches[0].clientY - this.initialY;\n            } else {\n                this.currentX = e.clientX - this.initialX;\n                this.currentY = e.clientY - this.initialY;\n            }\n            this.xOffset = this.currentX;\n            this.yOffset = this.currentY;\n            this.img.isDragging = true;\n            this.dragging = true;\n            this.setTranslate(this.img, this.currentX, this.currentY);\n        }\n    }\n    onMove(e) {\n        if (!this.zoomedIn) return;\n        let xOffset = e.clientX - this.img.naturalWidth / 2;\n        let yOffset = e.clientY - this.img.naturalHeight / 2;\n        this.setTranslate(this.img, xOffset, yOffset);\n    }\n    setTranslate(node, xPos, yPos) {\n        node.style.transform = \"translate3d(\" + xPos + \"px, \" + yPos + \"px, 0)\";\n    }\n    widowWidth() {\n        return window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n    }\n}\n\n\n/**\n * DragSlides\n * Allow imaes to be dragged for prev and next\n * in desktops\n *\n * @param { object } config\n */ \nclass $6c308edce205d329$export$2e2bcd8739ae039 {\n    constructor(config = {}){\n        let { dragEl: dragEl, toleranceX: toleranceX = 40, toleranceY: toleranceY = 65, slide: slide = null, instance: instance = null } = config;\n        this.el = dragEl;\n        this.active = false;\n        this.dragging = false;\n        this.currentX = null;\n        this.currentY = null;\n        this.initialX = null;\n        this.initialY = null;\n        this.xOffset = 0;\n        this.yOffset = 0;\n        this.direction = null;\n        this.lastDirection = null;\n        this.toleranceX = toleranceX;\n        this.toleranceY = toleranceY;\n        this.toleranceReached = false;\n        this.dragContainer = this.el;\n        this.slide = slide;\n        this.instance = instance;\n        this.el.addEventListener(\"mousedown\", (e)=>this.dragStart(e), false);\n        this.el.addEventListener(\"mouseup\", (e)=>this.dragEnd(e), false);\n        this.el.addEventListener(\"mousemove\", (e)=>this.drag(e), false);\n    }\n    dragStart(e) {\n        if (this.slide.classList.contains(\"zoomed\")) {\n            this.active = false;\n            return;\n        }\n        if (e.type === \"touchstart\") {\n            this.initialX = e.touches[0].clientX - this.xOffset;\n            this.initialY = e.touches[0].clientY - this.yOffset;\n        } else {\n            this.initialX = e.clientX - this.xOffset;\n            this.initialY = e.clientY - this.yOffset;\n        }\n        let clicked = e.target.nodeName.toLowerCase();\n        let exludeClicks = [\n            \"input\",\n            \"select\",\n            \"textarea\",\n            \"button\",\n            \"a\"\n        ];\n        if (e.target.classList.contains(\"nodrag\") || (0, $d8642219fb19b896$export$ff7f7c97cdce86e)(e.target, \".nodrag\") || exludeClicks.indexOf(clicked) !== -1) {\n            this.active = false;\n            return;\n        }\n        e.preventDefault();\n        if (e.target === this.el || clicked !== \"img\" && (0, $d8642219fb19b896$export$ff7f7c97cdce86e)(e.target, \".gslide-inline\")) {\n            this.active = true;\n            this.el.classList.add(\"dragging\");\n            this.dragContainer = (0, $d8642219fb19b896$export$ff7f7c97cdce86e)(e.target, \".ginner-container\");\n        }\n    }\n    dragEnd(e) {\n        e && e.preventDefault();\n        this.initialX = 0;\n        this.initialY = 0;\n        this.currentX = null;\n        this.currentY = null;\n        this.initialX = null;\n        this.initialY = null;\n        this.xOffset = 0;\n        this.yOffset = 0;\n        this.active = false;\n        if (this.doSlideChange) {\n            this.instance.preventOutsideClick = true;\n            this.doSlideChange == \"right\" && this.instance.prevSlide();\n            this.doSlideChange == \"left\" && this.instance.nextSlide();\n        }\n        if (this.doSlideClose) this.instance.close();\n        if (!this.toleranceReached) this.setTranslate(this.dragContainer, 0, 0, true);\n        setTimeout(()=>{\n            this.instance.preventOutsideClick = false;\n            this.toleranceReached = false;\n            this.lastDirection = null;\n            this.dragging = false;\n            this.el.isDragging = false;\n            this.el.classList.remove(\"dragging\");\n            this.slide.classList.remove(\"dragging-nav\");\n            this.dragContainer.style.transform = \"\";\n            this.dragContainer.style.transition = \"\";\n        }, 100);\n    }\n    drag(e) {\n        if (this.active) {\n            e.preventDefault();\n            this.slide.classList.add(\"dragging-nav\");\n            if (e.type === \"touchmove\") {\n                this.currentX = e.touches[0].clientX - this.initialX;\n                this.currentY = e.touches[0].clientY - this.initialY;\n            } else {\n                this.currentX = e.clientX - this.initialX;\n                this.currentY = e.clientY - this.initialY;\n            }\n            this.xOffset = this.currentX;\n            this.yOffset = this.currentY;\n            this.el.isDragging = true;\n            this.dragging = true;\n            this.doSlideChange = false;\n            this.doSlideClose = false;\n            let currentXInt = Math.abs(this.currentX);\n            let currentYInt = Math.abs(this.currentY);\n            // Horizontal drag\n            if (currentXInt > 0 && currentXInt >= Math.abs(this.currentY) && (!this.lastDirection || this.lastDirection == \"x\")) {\n                this.yOffset = 0;\n                this.lastDirection = \"x\";\n                this.setTranslate(this.dragContainer, this.currentX, 0);\n                let doChange = this.shouldChange();\n                if (!this.instance.settings.dragAutoSnap && doChange) this.doSlideChange = doChange;\n                if (this.instance.settings.dragAutoSnap && doChange) {\n                    this.instance.preventOutsideClick = true;\n                    this.toleranceReached = true;\n                    this.active = false;\n                    this.instance.preventOutsideClick = true;\n                    this.dragEnd(null);\n                    doChange == \"right\" && this.instance.prevSlide();\n                    doChange == \"left\" && this.instance.nextSlide();\n                    return;\n                }\n            }\n            // Vertical drag\n            if (this.toleranceY > 0 && currentYInt > 0 && currentYInt >= currentXInt && (!this.lastDirection || this.lastDirection == \"y\")) {\n                this.xOffset = 0;\n                this.lastDirection = \"y\";\n                this.setTranslate(this.dragContainer, 0, this.currentY);\n                let doClose = this.shouldClose();\n                if (!this.instance.settings.dragAutoSnap && doClose) this.doSlideClose = true;\n                if (this.instance.settings.dragAutoSnap && doClose) this.instance.close();\n                return;\n            }\n        }\n    }\n    shouldChange() {\n        let doChange = false;\n        let currentXInt = Math.abs(this.currentX);\n        if (currentXInt >= this.toleranceX) {\n            let dragDir = this.currentX > 0 ? \"right\" : \"left\";\n            if (dragDir == \"left\" && this.slide !== this.slide.parentNode.lastChild || dragDir == \"right\" && this.slide !== this.slide.parentNode.firstChild) doChange = dragDir;\n        }\n        return doChange;\n    }\n    shouldClose() {\n        let doClose = false;\n        let currentYInt = Math.abs(this.currentY);\n        if (currentYInt >= this.toleranceY) doClose = true;\n        return doClose;\n    }\n    setTranslate(node, xPos, yPos, animated = false) {\n        if (animated) node.style.transition = \"all .2s ease\";\n        else node.style.transition = \"\";\n        node.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;\n    }\n}\n\n\n/**\n * Set slide inline content\n * we'll extend this to make http\n * requests using the fetch api\n * but for now we keep it simple\n *\n * @param {node} slide\n * @param {object} data\n * @param {int} index\n * @param {function} callback\n */ \nfunction $739391bd372f739a$export$2e2bcd8739ae039(slide, data, index, callback) {\n    const slideMedia = slide.querySelector(\".gslide-media\");\n    let img = new Image();\n    let titleID = \"gSlideTitle_\" + index;\n    let textID = \"gSlideDesc_\" + index;\n    // prettier-ignore\n    img.addEventListener(\"load\", ()=>{\n        if ((0, $d8642219fb19b896$export$f6e2535fb5126e54)(callback)) callback();\n    }, false);\n    img.src = data.href;\n    if (data.sizes != \"\" && data.srcset != \"\") {\n        img.sizes = data.sizes;\n        img.srcset = data.srcset;\n    }\n    img.alt = \"\"; // https://davidwalsh.name/accessibility-tip-empty-alt-attributes\n    if (!(0, $d8642219fb19b896$export$984f70f9382f5d27)(data.alt) && data.alt !== \"\") img.alt = data.alt;\n    if (data.title !== \"\") img.setAttribute(\"aria-labelledby\", titleID);\n    if (data.description !== \"\") // https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-describedby_attribute#Example_2_A_Close_Button\n    img.setAttribute(\"aria-describedby\", textID);\n    if (data.hasOwnProperty(\"_hasCustomWidth\") && data._hasCustomWidth) img.style.width = data.width;\n    if (data.hasOwnProperty(\"_hasCustomHeight\") && data._hasCustomHeight) img.style.height = data.height;\n    slideMedia.insertBefore(img, slideMedia.firstChild);\n    return;\n}\n\n\n/**\n * Set slide video\n *\n * @param {node} slide\n * @param {object} data\n * @param {int} index\n * @param {function} callback\n */ \nfunction $2ce58134939997ad$export$2e2bcd8739ae039(slide, data, index, callback) {\n    const slideContainer = slide.querySelector(\".ginner-container\");\n    const videoID = \"gvideo\" + index;\n    const slideMedia = slide.querySelector(\".gslide-media\");\n    const videoPlayers = this.getAllPlayers();\n    (0, $d8642219fb19b896$export$d2cf6cd1dc7067d3)(slideContainer, \"gvideo-container\");\n    slideMedia.insertBefore((0, $d8642219fb19b896$export$8062c7bb2dbf069a)('<div class=\"gvideo-wrapper\"></div>'), slideMedia.firstChild);\n    const videoWrapper = slide.querySelector(\".gvideo-wrapper\");\n    (0, $d8642219fb19b896$export$27546899234f31f)(this.settings.plyr.css, \"Plyr\");\n    let url = data.href;\n    let provider = data?.videoProvider;\n    let customPlaceholder = false;\n    slideMedia.style.maxWidth = data.width;\n    (0, $d8642219fb19b896$export$27546899234f31f)(this.settings.plyr.js, \"Plyr\", ()=>{\n        // Set vimeo videos\n        if (!provider && url.match(/vimeo\\.com\\/([0-9]*)/)) provider = \"vimeo\";\n        // Set youtube videos\n        if (!provider && (url.match(/(youtube\\.com|youtube-nocookie\\.com)\\/watch\\?v=([a-zA-Z0-9\\-_]+)/) || url.match(/youtu\\.be\\/([a-zA-Z0-9\\-_]+)/) || url.match(/(youtube\\.com|youtube-nocookie\\.com)\\/embed\\/([a-zA-Z0-9\\-_]+)/) || url.match(/(youtube\\.com|youtube-nocookie\\.com)\\/shorts\\/([a-zA-Z0-9\\-_]+)/))) provider = \"youtube\";\n        // Set local videos\n        // if no provider, default to local\n        if (provider === \"local\" || !provider) {\n            provider = \"local\";\n            let html = '<video id=\"' + videoID + '\" ';\n            html += `style=\"background:#000; max-width: ${data.width};\" `;\n            html += 'preload=\"metadata\" ';\n            html += 'x-webkit-airplay=\"allow\" ';\n            html += \"playsinline \";\n            html += \"controls \";\n            html += 'class=\"gvideo-local\">';\n            html += `<source src=\"${url}\">`;\n            html += \"</video>\";\n            customPlaceholder = (0, $d8642219fb19b896$export$8062c7bb2dbf069a)(html);\n        }\n        // prettier-ignore\n        const placeholder = customPlaceholder ? customPlaceholder : (0, $d8642219fb19b896$export$8062c7bb2dbf069a)(`<div id=\"${videoID}\" data-plyr-provider=\"${provider}\" data-plyr-embed-id=\"${url}\"></div>`);\n        (0, $d8642219fb19b896$export$d2cf6cd1dc7067d3)(videoWrapper, `${provider}-video gvideo`);\n        videoWrapper.appendChild(placeholder);\n        videoWrapper.setAttribute(\"data-id\", videoID);\n        videoWrapper.setAttribute(\"data-index\", index);\n        const playerConfig = (0, $d8642219fb19b896$export$a4f4bb6b1453fff5)(this.settings.plyr, \"config\") ? this.settings.plyr.config : {};\n        const player = new Plyr(\"#\" + videoID, playerConfig);\n        player.on(\"ready\", (event)=>{\n            videoPlayers[videoID] = event.detail.plyr;\n            if ((0, $d8642219fb19b896$export$f6e2535fb5126e54)(callback)) callback();\n        });\n        (0, $d8642219fb19b896$export$4e57ed416e50788e)(()=>{\n            return slide.querySelector(\"iframe\") && slide.querySelector(\"iframe\").dataset.ready == \"true\";\n        }, ()=>{\n            this.resize(slide);\n        });\n        player.on(\"enterfullscreen\", $2ce58134939997ad$var$handleMediaFullScreen);\n        player.on(\"exitfullscreen\", $2ce58134939997ad$var$handleMediaFullScreen);\n    });\n}\n/**\n * Handle fullscreen\n *\n * @param {object} event\n */ function $2ce58134939997ad$var$handleMediaFullScreen(event) {\n    const media = (0, $d8642219fb19b896$export$ff7f7c97cdce86e)(event.target, \".gslide-media\");\n    if (event.type === \"enterfullscreen\") (0, $d8642219fb19b896$export$d2cf6cd1dc7067d3)(media, \"fullscreen\");\n    if (event.type === \"exitfullscreen\") (0, $d8642219fb19b896$export$c2255604a80b4506)(media, \"fullscreen\");\n}\n\n\n/**\n * Set slide inline content\n * we'll extend this to make http\n * requests using the fetch api\n * but for now we keep it simple\n *\n * @param {node} slide\n * @param {object} data\n * @param {int} index\n * @param {function} callback\n */ \nfunction $531b961811254e85$export$2e2bcd8739ae039(slide, data, index, callback) {\n    const slideMedia = slide.querySelector(\".gslide-media\");\n    const hash = (0, $d8642219fb19b896$export$a4f4bb6b1453fff5)(data, \"href\") && data.href ? data.href.split(\"#\").pop().trim() : false;\n    const content = (0, $d8642219fb19b896$export$a4f4bb6b1453fff5)(data, \"content\") && data.content ? data.content : false;\n    let innerContent;\n    if (content) {\n        if ((0, $d8642219fb19b896$export$844ec244b1367d54)(content)) innerContent = (0, $d8642219fb19b896$export$8062c7bb2dbf069a)(`<div class=\"ginlined-content\">${content}</div>`);\n        if ((0, $d8642219fb19b896$export$8ee0fc9ee280b4ee)(content)) {\n            if (content.style.display == \"none\") content.style.display = \"block\";\n            const container = document.createElement(\"div\");\n            container.className = \"ginlined-content\";\n            container.appendChild(content);\n            innerContent = container;\n        }\n    }\n    if (hash) {\n        let div = document.getElementById(hash);\n        if (!div) return false;\n        const cloned = div.cloneNode(true);\n        cloned.style.height = data.height;\n        cloned.style.maxWidth = data.width;\n        (0, $d8642219fb19b896$export$d2cf6cd1dc7067d3)(cloned, \"ginlined-content\");\n        innerContent = cloned;\n    }\n    if (!innerContent) {\n        console.error(\"Unable to append inline slide content\", data);\n        return false;\n    }\n    slideMedia.style.height = data.height;\n    slideMedia.style.width = data.width;\n    slideMedia.appendChild(innerContent);\n    this.events[\"inlineclose\" + hash] = (0, $d8642219fb19b896$export$f531f92e2a15358f)(\"click\", {\n        onElement: slideMedia.querySelectorAll(\".gtrigger-close\"),\n        withCallback: (e)=>{\n            e.preventDefault();\n            this.close();\n        }\n    });\n    if ((0, $d8642219fb19b896$export$f6e2535fb5126e54)(callback)) callback();\n    return;\n}\n\n\n/**\n * Set slide iframe content\n *\n * @param {node} slide\n * @param {object} data\n * @param {int} index\n * @param {function} callback\n */ \nfunction $616194498e537ffc$export$2e2bcd8739ae039(slide, data, index, callback) {\n    const slideMedia = slide.querySelector(\".gslide-media\");\n    const iframe = (0, $d8642219fb19b896$export$eca25244f8f7df8e)({\n        url: data.href,\n        callback: callback\n    });\n    slideMedia.parentNode.style.maxWidth = data.width;\n    slideMedia.parentNode.style.height = data.height;\n    slideMedia.appendChild(iframe);\n    return;\n}\n\n\n\nclass $642e7e2c0e9e2e8d$export$2e2bcd8739ae039 {\n    constructor(slideParamas = {}){\n        this.defaults = {\n            href: \"\",\n            sizes: \"\",\n            srcset: \"\",\n            title: \"\",\n            type: \"\",\n            videoProvider: \"\",\n            description: \"\",\n            alt: \"\",\n            descPosition: \"bottom\",\n            effect: \"\",\n            width: \"\",\n            height: \"\",\n            content: false,\n            zoomable: true,\n            draggable: true\n        };\n        if ((0, $d8642219fb19b896$export$a6cdc56e425d0d0a)(slideParamas)) this.defaults = (0, $d8642219fb19b896$export$8b58be045bf06082)(this.defaults, slideParamas);\n    }\n    /**\n     * Get source type\n     * gte the source type of a url\n     *\n     * @param {string} url\n     */ sourceType(url) {\n        let origin = url;\n        url = url.toLowerCase();\n        if (url.match(/\\.(jpeg|jpg|jpe|gif|png|apn|webp|avif|svg)/) !== null) return \"image\";\n        if (url.match(/(youtube\\.com|youtube-nocookie\\.com)\\/watch\\?v=([a-zA-Z0-9\\-_]+)/) || url.match(/youtu\\.be\\/([a-zA-Z0-9\\-_]+)/) || url.match(/(youtube\\.com|youtube-nocookie\\.com)\\/embed\\/([a-zA-Z0-9\\-_]+)/) || url.match(/(youtube\\.com|youtube-nocookie\\.com)\\/shorts\\/([a-zA-Z0-9\\-_]+)/)) return \"video\";\n        if (url.match(/vimeo\\.com\\/([0-9]*)/)) return \"video\";\n        if (url.match(/\\.(mp4|ogg|webm|mov)/) !== null) return \"video\";\n        if (url.match(/\\.(mp3|wav|wma|aac|ogg)/) !== null) return \"audio\";\n        // Check if inline content\n        if (url.indexOf(\"#\") > -1) {\n            let hash = origin.split(\"#\").pop();\n            if (hash.trim() !== \"\") return \"inline\";\n        }\n        // Ajax\n        if (url.indexOf(\"goajax=true\") > -1) return \"ajax\";\n        return \"external\";\n    }\n    parseConfig(element, settings) {\n        let data = (0, $d8642219fb19b896$export$8b58be045bf06082)({\n            descPosition: settings.descPosition\n        }, this.defaults);\n        if ((0, $d8642219fb19b896$export$a6cdc56e425d0d0a)(element) && !(0, $d8642219fb19b896$export$8ee0fc9ee280b4ee)(element)) {\n            if (!(0, $d8642219fb19b896$export$a4f4bb6b1453fff5)(element, \"type\")) {\n                if ((0, $d8642219fb19b896$export$a4f4bb6b1453fff5)(element, \"content\") && element.content) element.type = \"inline\";\n                else if ((0, $d8642219fb19b896$export$a4f4bb6b1453fff5)(element, \"href\")) element.type = this.sourceType(element.href);\n            }\n            let objectData = (0, $d8642219fb19b896$export$8b58be045bf06082)(data, element);\n            this.setSize(objectData, settings);\n            return objectData;\n        }\n        let url = \"\";\n        let config = element.getAttribute(\"data-glightbox\");\n        let nodeType = element.nodeName.toLowerCase();\n        if (nodeType === \"a\") url = element.href;\n        if (nodeType === \"img\") {\n            url = element.src;\n            //alt attribute propagation\n            data.alt = element.alt;\n        }\n        data.href = url;\n        (0, $d8642219fb19b896$export$79b2f7037acddd43)(data, (val, key)=>{\n            if ((0, $d8642219fb19b896$export$a4f4bb6b1453fff5)(settings, key) && key !== \"width\") data[key] = settings[key];\n            const nodeData = element.dataset[key];\n            if (!(0, $d8642219fb19b896$export$984f70f9382f5d27)(nodeData)) data[key] = this.sanitizeValue(nodeData);\n        });\n        if (data.content) data.type = \"inline\";\n        if (!data.type && url) data.type = this.sourceType(url);\n        if (!(0, $d8642219fb19b896$export$984f70f9382f5d27)(config)) {\n            let cleanKeys = [];\n            (0, $d8642219fb19b896$export$79b2f7037acddd43)(data, (v, k)=>{\n                cleanKeys.push(\";\\\\s?\" + k);\n            });\n            cleanKeys = cleanKeys.join(\"\\\\s?:|\");\n            if (config.trim() !== \"\") (0, $d8642219fb19b896$export$79b2f7037acddd43)(data, (val, key)=>{\n                const str = config;\n                const match = \"s?\" + key + \"s?:s?(.*?)(\" + cleanKeys + \"s?:|$)\";\n                const regex = new RegExp(match);\n                const matches = str.match(regex);\n                if (matches && matches.length && matches[1]) {\n                    const value = matches[1].trim().replace(/;\\s*$/, \"\");\n                    data[key] = this.sanitizeValue(value);\n                }\n            });\n        } else {\n            if (!data.title && nodeType == \"a\") {\n                let title = element.title;\n                if (!(0, $d8642219fb19b896$export$984f70f9382f5d27)(title) && title !== \"\") data.title = title;\n            }\n            if (!data.title && nodeType == \"img\") {\n                let alt = element.alt;\n                if (!(0, $d8642219fb19b896$export$984f70f9382f5d27)(alt) && alt !== \"\") data.title = alt;\n            }\n        }\n        // Try to get the description from a referenced element\n        if (data.description && data.description.substring(0, 1) === \".\") {\n            let description;\n            try {\n                description = document.querySelector(data.description).innerHTML;\n            } catch (error) {\n                if (!(error instanceof DOMException)) throw error;\n            }\n            if (description) data.description = description;\n        }\n        // Try to get the description from a .glightbox-desc element\n        if (!data.description) {\n            let nodeDesc = element.querySelector(\".glightbox-desc\");\n            if (nodeDesc) data.description = nodeDesc.innerHTML;\n        }\n        this.setSize(data, settings, element);\n        this.slideConfig = data;\n        return data;\n    }\n    /**\n     * Set slide data size\n     * set the correct size dependin\n     * on the slide type\n     *\n     * @param { object } data\n     * @param { object } settings\n     * @return { object }\n     */ setSize(data, settings, element = null) {\n        const defaultWith = data.type == \"video\" ? this.checkSize(settings.videosWidth) : this.checkSize(settings.width);\n        const defaultHeight = this.checkSize(settings.height);\n        data.width = (0, $d8642219fb19b896$export$a4f4bb6b1453fff5)(data, \"width\") && data.width !== \"\" ? this.checkSize(data.width) : defaultWith;\n        data.height = (0, $d8642219fb19b896$export$a4f4bb6b1453fff5)(data, \"height\") && data.height !== \"\" ? this.checkSize(data.height) : defaultHeight;\n        if (element && data.type == \"image\") {\n            data._hasCustomWidth = element.dataset.width ? true : false;\n            data._hasCustomHeight = element.dataset.height ? true : false;\n        }\n        return data;\n    }\n    /**\n     * [checkSize size\n     * check if the passed size has a correct unit\n     *\n     * @param {string} size\n     * @return {string}\n     */ checkSize(size) {\n        return (0, $d8642219fb19b896$export$7e4aa119212bc614)(size) ? `${size}px` : size;\n    }\n    /**\n     * Sanitize data attributes value\n     *\n     * @param string val\n     * @return mixed\n     */ sanitizeValue(val) {\n        if (val !== \"true\" && val !== \"false\") return val;\n        return val === \"true\";\n    }\n}\n\n\n\nclass $b1ff45689b2e6929$export$2e2bcd8739ae039 {\n    constructor(el, instance, index){\n        this.element = el;\n        this.instance = instance;\n        this.index = index;\n    }\n    /**\n     * Set slide content\n     *\n     * @param {node} slide\n     * @param {object} data\n     * @param {function} callback\n     */ setContent(slide = null, callback = false) {\n        if ((0, $d8642219fb19b896$export$4ea3d958472af68f)(slide, \"loaded\")) return false;\n        const settings = this.instance.settings;\n        const slideConfig = this.slideConfig;\n        const isMobileDevice = (0, $d8642219fb19b896$export$d0a8044dce8ff2fc)();\n        if ((0, $d8642219fb19b896$export$f6e2535fb5126e54)(settings.beforeSlideLoad)) settings.beforeSlideLoad({\n            index: this.index,\n            slide: slide,\n            player: false\n        });\n        let type = slideConfig.type;\n        let position = slideConfig.descPosition;\n        let slideMedia = slide.querySelector(\".gslide-media\");\n        let slideTitle = slide.querySelector(\".gslide-title\");\n        let slideText = slide.querySelector(\".gslide-desc\");\n        let slideDesc = slide.querySelector(\".gdesc-inner\");\n        let finalCallback = callback;\n        // used for image accessiblity\n        let titleID = \"gSlideTitle_\" + this.index;\n        let textID = \"gSlideDesc_\" + this.index;\n        if ((0, $d8642219fb19b896$export$f6e2535fb5126e54)(settings.afterSlideLoad)) finalCallback = ()=>{\n            if ((0, $d8642219fb19b896$export$f6e2535fb5126e54)(callback)) callback();\n            settings.afterSlideLoad({\n                index: this.index,\n                slide: slide,\n                player: this.instance.getSlidePlayerInstance(this.index)\n            });\n        };\n        if (slideConfig.title == \"\" && slideConfig.description == \"\") {\n            if (slideDesc) slideDesc.parentNode.parentNode.removeChild(slideDesc.parentNode);\n        } else {\n            if (slideTitle && slideConfig.title !== \"\") {\n                slideTitle.id = titleID;\n                slideTitle.innerHTML = slideConfig.title;\n            } else slideTitle.parentNode.removeChild(slideTitle);\n            if (slideText && slideConfig.description !== \"\") {\n                slideText.id = textID;\n                if (isMobileDevice && settings.moreLength > 0) {\n                    slideConfig.smallDescription = this.slideShortDesc(slideConfig.description, settings.moreLength, settings.moreText);\n                    slideText.innerHTML = slideConfig.smallDescription;\n                    this.descriptionEvents(slideText, slideConfig);\n                } else slideText.innerHTML = slideConfig.description;\n            } else slideText.parentNode.removeChild(slideText);\n            (0, $d8642219fb19b896$export$d2cf6cd1dc7067d3)(slideMedia.parentNode, `desc-${position}`);\n            (0, $d8642219fb19b896$export$d2cf6cd1dc7067d3)(slideDesc.parentNode, `description-${position}`);\n        }\n        (0, $d8642219fb19b896$export$d2cf6cd1dc7067d3)(slideMedia, `gslide-${type}`);\n        (0, $d8642219fb19b896$export$d2cf6cd1dc7067d3)(slide, \"loaded\");\n        if (type === \"video\") {\n            (0, $2ce58134939997ad$export$2e2bcd8739ae039).apply(this.instance, [\n                slide,\n                slideConfig,\n                this.index,\n                finalCallback\n            ]);\n            return;\n        }\n        if (type === \"external\") {\n            (0, $616194498e537ffc$export$2e2bcd8739ae039).apply(this, [\n                slide,\n                slideConfig,\n                this.index,\n                finalCallback\n            ]);\n            return;\n        }\n        if (type === \"inline\") {\n            (0, $531b961811254e85$export$2e2bcd8739ae039).apply(this.instance, [\n                slide,\n                slideConfig,\n                this.index,\n                finalCallback\n            ]);\n            if (slideConfig.draggable) new (0, $6c308edce205d329$export$2e2bcd8739ae039)({\n                dragEl: slide.querySelector(\".gslide-inline\"),\n                toleranceX: settings.dragToleranceX,\n                toleranceY: settings.dragToleranceY,\n                slide: slide,\n                instance: this.instance\n            });\n            return;\n        }\n        if (type === \"image\") {\n            (0, $739391bd372f739a$export$2e2bcd8739ae039)(slide, slideConfig, this.index, ()=>{\n                const img = slide.querySelector(\"img\");\n                if (slideConfig.draggable) new (0, $6c308edce205d329$export$2e2bcd8739ae039)({\n                    dragEl: img,\n                    toleranceX: settings.dragToleranceX,\n                    toleranceY: settings.dragToleranceY,\n                    slide: slide,\n                    instance: this.instance\n                });\n                if (slideConfig.zoomable && img.naturalWidth > img.offsetWidth) {\n                    (0, $d8642219fb19b896$export$d2cf6cd1dc7067d3)(img, \"zoomable\");\n                    new (0, $0bb52a7e29744ad2$export$2e2bcd8739ae039)(img, slide, ()=>{\n                        this.instance.resize();\n                    });\n                }\n                if ((0, $d8642219fb19b896$export$f6e2535fb5126e54)(finalCallback)) finalCallback();\n            });\n            return;\n        }\n        if ((0, $d8642219fb19b896$export$f6e2535fb5126e54)(finalCallback)) finalCallback();\n    }\n    slideShortDesc(string, n = 50, wordBoundary = false) {\n        let div = document.createElement(\"div\");\n        div.innerHTML = string;\n        let cleanedString = div.innerText;\n        let useWordBoundary = wordBoundary;\n        string = cleanedString.trim();\n        if (string.length <= n) return string;\n        let subString = string.substr(0, n - 1);\n        if (!useWordBoundary) return subString;\n        div = null;\n        return subString + '... <a href=\"#\" class=\"desc-more\">' + wordBoundary + \"</a>\";\n    }\n    descriptionEvents(desc, data) {\n        let moreLink = desc.querySelector(\".desc-more\");\n        if (!moreLink) return false;\n        (0, $d8642219fb19b896$export$f531f92e2a15358f)(\"click\", {\n            onElement: moreLink,\n            withCallback: (event, target)=>{\n                event.preventDefault();\n                const body = document.body;\n                let desc = (0, $d8642219fb19b896$export$ff7f7c97cdce86e)(target, \".gslide-desc\");\n                if (!desc) return false;\n                desc.innerHTML = data.description;\n                (0, $d8642219fb19b896$export$d2cf6cd1dc7067d3)(body, \"gdesc-open\");\n                let shortEvent = (0, $d8642219fb19b896$export$f531f92e2a15358f)(\"click\", {\n                    onElement: [\n                        body,\n                        (0, $d8642219fb19b896$export$ff7f7c97cdce86e)(desc, \".gslide-description\")\n                    ],\n                    withCallback: (event, target)=>{\n                        if (event.target.nodeName.toLowerCase() !== \"a\") {\n                            (0, $d8642219fb19b896$export$c2255604a80b4506)(body, \"gdesc-open\");\n                            (0, $d8642219fb19b896$export$d2cf6cd1dc7067d3)(body, \"gdesc-closed\");\n                            desc.innerHTML = data.smallDescription;\n                            this.descriptionEvents(desc, data);\n                            setTimeout(()=>{\n                                (0, $d8642219fb19b896$export$c2255604a80b4506)(body, \"gdesc-closed\");\n                            }, 400);\n                            shortEvent.destroy();\n                        }\n                    }\n                });\n            }\n        });\n    }\n    /**\n     * Create Slide Node\n     *\n     * @return { node }\n     */ create() {\n        return (0, $d8642219fb19b896$export$8062c7bb2dbf069a)(this.instance.settings.slideHTML);\n    }\n    /**\n     * Get slide config\n     * returns each individual slide config\n     * it uses SlideConfigParser\n     * each slide can overwrite a global setting\n     * read more in the SlideConfigParser class\n     *\n     * @return { object }\n     */ getConfig() {\n        if (!(0, $d8642219fb19b896$export$8ee0fc9ee280b4ee)(this.element) && !this.element.hasOwnProperty(\"draggable\")) this.element.draggable = this.instance.settings.draggable;\n        const parser = new (0, $642e7e2c0e9e2e8d$export$2e2bcd8739ae039)(this.instance.settings.slideExtraAttributes);\n        this.slideConfig = parser.parseConfig(this.element, this.instance.settings);\n        return this.slideConfig;\n    }\n}\n\n\n/**\n * Touch Navigation\n * Allow navigation using touch events\n *\n * @param {object} instance\n */ function $48e1c8ad9a0e0bf1$var$getLen(v) {\n    return Math.sqrt(v.x * v.x + v.y * v.y);\n}\nfunction $48e1c8ad9a0e0bf1$var$dot(v1, v2) {\n    return v1.x * v2.x + v1.y * v2.y;\n}\nfunction $48e1c8ad9a0e0bf1$var$getAngle(v1, v2) {\n    var mr = $48e1c8ad9a0e0bf1$var$getLen(v1) * $48e1c8ad9a0e0bf1$var$getLen(v2);\n    if (mr === 0) return 0;\n    var r = $48e1c8ad9a0e0bf1$var$dot(v1, v2) / mr;\n    if (r > 1) r = 1;\n    return Math.acos(r);\n}\nfunction $48e1c8ad9a0e0bf1$var$cross(v1, v2) {\n    return v1.x * v2.y - v2.x * v1.y;\n}\nfunction $48e1c8ad9a0e0bf1$var$getRotateAngle(v1, v2) {\n    var angle = $48e1c8ad9a0e0bf1$var$getAngle(v1, v2);\n    if ($48e1c8ad9a0e0bf1$var$cross(v1, v2) > 0) angle *= -1;\n    return angle * 180 / Math.PI;\n}\nclass $48e1c8ad9a0e0bf1$var$EventsHandlerAdmin {\n    constructor(el){\n        this.handlers = [];\n        this.el = el;\n    }\n    add(handler) {\n        this.handlers.push(handler);\n    }\n    del(handler) {\n        if (!handler) this.handlers = [];\n        for(var i = this.handlers.length; i >= 0; i--)if (this.handlers[i] === handler) this.handlers.splice(i, 1);\n    }\n    dispatch() {\n        for(var i = 0, len = this.handlers.length; i < len; i++){\n            var handler = this.handlers[i];\n            if (typeof handler === \"function\") handler.apply(this.el, arguments);\n        }\n    }\n}\nfunction $48e1c8ad9a0e0bf1$var$wrapFunc(el, handler) {\n    var EventshandlerAdmin = new $48e1c8ad9a0e0bf1$var$EventsHandlerAdmin(el);\n    EventshandlerAdmin.add(handler);\n    return EventshandlerAdmin;\n}\nclass $48e1c8ad9a0e0bf1$export$2e2bcd8739ae039 {\n    constructor(el, option){\n        this.element = typeof el == \"string\" ? document.querySelector(el) : el;\n        this.start = this.start.bind(this);\n        this.move = this.move.bind(this);\n        this.end = this.end.bind(this);\n        this.cancel = this.cancel.bind(this);\n        this.element.addEventListener(\"touchstart\", this.start, false);\n        this.element.addEventListener(\"touchmove\", this.move, false);\n        this.element.addEventListener(\"touchend\", this.end, false);\n        this.element.addEventListener(\"touchcancel\", this.cancel, false);\n        this.preV = {\n            x: null,\n            y: null\n        };\n        this.pinchStartLen = null;\n        this.zoom = 1;\n        this.isDoubleTap = false;\n        var noop = function() {};\n        this.rotate = $48e1c8ad9a0e0bf1$var$wrapFunc(this.element, option.rotate || noop);\n        this.touchStart = $48e1c8ad9a0e0bf1$var$wrapFunc(this.element, option.touchStart || noop);\n        this.multipointStart = $48e1c8ad9a0e0bf1$var$wrapFunc(this.element, option.multipointStart || noop);\n        this.multipointEnd = $48e1c8ad9a0e0bf1$var$wrapFunc(this.element, option.multipointEnd || noop);\n        this.pinch = $48e1c8ad9a0e0bf1$var$wrapFunc(this.element, option.pinch || noop);\n        this.swipe = $48e1c8ad9a0e0bf1$var$wrapFunc(this.element, option.swipe || noop);\n        this.tap = $48e1c8ad9a0e0bf1$var$wrapFunc(this.element, option.tap || noop);\n        this.doubleTap = $48e1c8ad9a0e0bf1$var$wrapFunc(this.element, option.doubleTap || noop);\n        this.longTap = $48e1c8ad9a0e0bf1$var$wrapFunc(this.element, option.longTap || noop);\n        this.singleTap = $48e1c8ad9a0e0bf1$var$wrapFunc(this.element, option.singleTap || noop);\n        this.pressMove = $48e1c8ad9a0e0bf1$var$wrapFunc(this.element, option.pressMove || noop);\n        this.twoFingerPressMove = $48e1c8ad9a0e0bf1$var$wrapFunc(this.element, option.twoFingerPressMove || noop);\n        this.touchMove = $48e1c8ad9a0e0bf1$var$wrapFunc(this.element, option.touchMove || noop);\n        this.touchEnd = $48e1c8ad9a0e0bf1$var$wrapFunc(this.element, option.touchEnd || noop);\n        this.touchCancel = $48e1c8ad9a0e0bf1$var$wrapFunc(this.element, option.touchCancel || noop);\n        this.translateContainer = this.element;\n        this._cancelAllHandler = this.cancelAll.bind(this);\n        window.addEventListener(\"scroll\", this._cancelAllHandler);\n        this.delta = null;\n        this.last = null;\n        this.now = null;\n        this.tapTimeout = null;\n        this.singleTapTimeout = null;\n        this.longTapTimeout = null;\n        this.swipeTimeout = null;\n        this.x1 = this.x2 = this.y1 = this.y2 = null;\n        this.preTapPosition = {\n            x: null,\n            y: null\n        };\n    }\n    start(evt) {\n        if (!evt.touches) return;\n        // Fix Media Buttons Not responding on Android #233\n        const ignoreDragFor = [\n            \"a\",\n            \"button\",\n            \"input\"\n        ];\n        if (evt.target && evt.target.nodeName && ignoreDragFor.indexOf(evt.target.nodeName.toLowerCase()) >= 0) {\n            console.log(\"ignore drag for this touched element\", evt.target.nodeName.toLowerCase());\n            return;\n        }\n        this.now = Date.now();\n        this.x1 = evt.touches[0].pageX;\n        this.y1 = evt.touches[0].pageY;\n        this.delta = this.now - (this.last || this.now);\n        this.touchStart.dispatch(evt, this.element);\n        if (this.preTapPosition.x !== null) {\n            this.isDoubleTap = this.delta > 0 && this.delta <= 250 && Math.abs(this.preTapPosition.x - this.x1) < 30 && Math.abs(this.preTapPosition.y - this.y1) < 30;\n            if (this.isDoubleTap) clearTimeout(this.singleTapTimeout);\n        }\n        this.preTapPosition.x = this.x1;\n        this.preTapPosition.y = this.y1;\n        this.last = this.now;\n        var preV = this.preV, len = evt.touches.length;\n        if (len > 1) {\n            this._cancelLongTap();\n            this._cancelSingleTap();\n            var v = {\n                x: evt.touches[1].pageX - this.x1,\n                y: evt.touches[1].pageY - this.y1\n            };\n            preV.x = v.x;\n            preV.y = v.y;\n            this.pinchStartLen = $48e1c8ad9a0e0bf1$var$getLen(preV);\n            this.multipointStart.dispatch(evt, this.element);\n        }\n        this._preventTap = false;\n        this.longTapTimeout = setTimeout((function() {\n            this.longTap.dispatch(evt, this.element);\n            this._preventTap = true;\n        }).bind(this), 750);\n    }\n    move(evt) {\n        if (!evt.touches) return;\n        var preV = this.preV, len = evt.touches.length, currentX = evt.touches[0].pageX, currentY = evt.touches[0].pageY;\n        this.isDoubleTap = false;\n        if (len > 1) {\n            var sCurrentX = evt.touches[1].pageX, sCurrentY = evt.touches[1].pageY;\n            var v = {\n                x: evt.touches[1].pageX - currentX,\n                y: evt.touches[1].pageY - currentY\n            };\n            if (preV.x !== null) {\n                if (this.pinchStartLen > 0) {\n                    evt.zoom = $48e1c8ad9a0e0bf1$var$getLen(v) / this.pinchStartLen;\n                    this.pinch.dispatch(evt, this.element);\n                }\n                evt.angle = $48e1c8ad9a0e0bf1$var$getRotateAngle(v, preV);\n                this.rotate.dispatch(evt, this.element);\n            }\n            preV.x = v.x;\n            preV.y = v.y;\n            if (this.x2 !== null && this.sx2 !== null) {\n                evt.deltaX = (currentX - this.x2 + sCurrentX - this.sx2) / 2;\n                evt.deltaY = (currentY - this.y2 + sCurrentY - this.sy2) / 2;\n            } else {\n                evt.deltaX = 0;\n                evt.deltaY = 0;\n            }\n            this.twoFingerPressMove.dispatch(evt, this.element);\n            this.sx2 = sCurrentX;\n            this.sy2 = sCurrentY;\n        } else {\n            if (this.x2 !== null) {\n                evt.deltaX = currentX - this.x2;\n                evt.deltaY = currentY - this.y2;\n                var movedX = Math.abs(this.x1 - this.x2), movedY = Math.abs(this.y1 - this.y2);\n                if (movedX > 10 || movedY > 10) this._preventTap = true;\n            } else {\n                evt.deltaX = 0;\n                evt.deltaY = 0;\n            }\n            this.pressMove.dispatch(evt, this.element);\n        }\n        this.touchMove.dispatch(evt, this.element);\n        this._cancelLongTap();\n        this.x2 = currentX;\n        this.y2 = currentY;\n        if (len > 1) evt.preventDefault();\n    }\n    end(evt) {\n        if (!evt.changedTouches) return;\n        this._cancelLongTap();\n        var self = this;\n        if (evt.touches.length < 2) {\n            this.multipointEnd.dispatch(evt, this.element);\n            this.sx2 = this.sy2 = null;\n        }\n        //swipe\n        if (this.x2 && Math.abs(this.x1 - this.x2) > 30 || this.y2 && Math.abs(this.y1 - this.y2) > 30) {\n            evt.direction = this._swipeDirection(this.x1, this.x2, this.y1, this.y2);\n            this.swipeTimeout = setTimeout(function() {\n                self.swipe.dispatch(evt, self.element);\n            }, 0);\n        } else {\n            this.tapTimeout = setTimeout(function() {\n                if (!self._preventTap) self.tap.dispatch(evt, self.element);\n                // trigger double tap immediately\n                if (self.isDoubleTap) {\n                    self.doubleTap.dispatch(evt, self.element);\n                    self.isDoubleTap = false;\n                }\n            }, 0);\n            if (!self.isDoubleTap) self.singleTapTimeout = setTimeout(function() {\n                self.singleTap.dispatch(evt, self.element);\n            }, 250);\n        }\n        this.touchEnd.dispatch(evt, this.element);\n        this.preV.x = 0;\n        this.preV.y = 0;\n        this.zoom = 1;\n        this.pinchStartLen = null;\n        this.x1 = this.x2 = this.y1 = this.y2 = null;\n    }\n    cancelAll() {\n        this._preventTap = true;\n        clearTimeout(this.singleTapTimeout);\n        clearTimeout(this.tapTimeout);\n        clearTimeout(this.longTapTimeout);\n        clearTimeout(this.swipeTimeout);\n    }\n    cancel(evt) {\n        this.cancelAll();\n        this.touchCancel.dispatch(evt, this.element);\n    }\n    _cancelLongTap() {\n        clearTimeout(this.longTapTimeout);\n    }\n    _cancelSingleTap() {\n        clearTimeout(this.singleTapTimeout);\n    }\n    _swipeDirection(x1, x2, y1, y2) {\n        return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ? x1 - x2 > 0 ? \"Left\" : \"Right\" : y1 - y2 > 0 ? \"Up\" : \"Down\";\n    }\n    on(evt, handler) {\n        if (this[evt]) this[evt].add(handler);\n    }\n    off(evt, handler) {\n        if (this[evt]) this[evt].del(handler);\n    }\n    destroy() {\n        if (this.singleTapTimeout) clearTimeout(this.singleTapTimeout);\n        if (this.tapTimeout) clearTimeout(this.tapTimeout);\n        if (this.longTapTimeout) clearTimeout(this.longTapTimeout);\n        if (this.swipeTimeout) clearTimeout(this.swipeTimeout);\n        this.element.removeEventListener(\"touchstart\", this.start);\n        this.element.removeEventListener(\"touchmove\", this.move);\n        this.element.removeEventListener(\"touchend\", this.end);\n        this.element.removeEventListener(\"touchcancel\", this.cancel);\n        this.rotate.del();\n        this.touchStart.del();\n        this.multipointStart.del();\n        this.multipointEnd.del();\n        this.pinch.del();\n        this.swipe.del();\n        this.tap.del();\n        this.doubleTap.del();\n        this.longTap.del();\n        this.singleTap.del();\n        this.pressMove.del();\n        this.twoFingerPressMove.del();\n        this.touchMove.del();\n        this.touchEnd.del();\n        this.touchCancel.del();\n        this.preV = this.pinchStartLen = this.zoom = this.isDoubleTap = this.delta = this.last = this.now = this.tapTimeout = this.singleTapTimeout = this.longTapTimeout = this.swipeTimeout = this.x1 = this.x2 = this.y1 = this.y2 = this.preTapPosition = this.rotate = this.touchStart = this.multipointStart = this.multipointEnd = this.pinch = this.swipe = this.tap = this.doubleTap = this.longTap = this.singleTap = this.pressMove = this.touchMove = this.touchEnd = this.touchCancel = this.twoFingerPressMove = null;\n        window.removeEventListener(\"scroll\", this._cancelAllHandler);\n        return null;\n    }\n}\n\n\n\nfunction $8cb9d8feeacb1ed6$var$resetSlideMove(slide) {\n    const transitionEnd = (0, $d8642219fb19b896$export$bd36fba2d672470e)();\n    const windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n    let media = (0, $d8642219fb19b896$export$4ea3d958472af68f)(slide, \"gslide-media\") ? slide : slide.querySelector(\".gslide-media\");\n    let container = (0, $d8642219fb19b896$export$ff7f7c97cdce86e)(media, \".ginner-container\");\n    let desc = slide.querySelector(\".gslide-description\");\n    if (windowWidth > 769) media = container;\n    (0, $d8642219fb19b896$export$d2cf6cd1dc7067d3)(media, \"greset\");\n    (0, $d8642219fb19b896$export$fd43050ca342497c)(media, \"translate3d(0, 0, 0)\");\n    (0, $d8642219fb19b896$export$f531f92e2a15358f)(transitionEnd, {\n        onElement: media,\n        once: true,\n        withCallback: (event, target)=>{\n            (0, $d8642219fb19b896$export$c2255604a80b4506)(media, \"greset\");\n        }\n    });\n    media.style.opacity = \"\";\n    if (desc) desc.style.opacity = \"\";\n}\nfunction $8cb9d8feeacb1ed6$export$2e2bcd8739ae039(instance) {\n    if (instance.events.hasOwnProperty(\"touch\")) return false;\n    let winSize = (0, $d8642219fb19b896$export$994b0103697d2bf)();\n    let winWidth = winSize.width;\n    let winHeight = winSize.height;\n    let process = false;\n    let currentSlide = null;\n    let media = null;\n    let mediaImage = null;\n    let doingMove = false;\n    let initScale = 1;\n    let maxScale = 4.5;\n    let currentScale = 1;\n    let doingZoom = false;\n    let imageZoomed = false;\n    let zoomedPosX = null;\n    let zoomedPosY = null;\n    let lastZoomedPosX = null;\n    let lastZoomedPosY = null;\n    let hDistance;\n    let vDistance;\n    let hDistancePercent = 0;\n    let vDistancePercent = 0;\n    let vSwipe = false;\n    let hSwipe = false;\n    let startCoords = {};\n    let endCoords = {};\n    let xDown = 0;\n    let yDown = 0;\n    let isInlined;\n    const sliderWrapper = document.getElementById(\"glightbox-slider\");\n    const overlay = document.querySelector(\".goverlay\");\n    const touchInstance = new (0, $48e1c8ad9a0e0bf1$export$2e2bcd8739ae039)(sliderWrapper, {\n        touchStart: (e)=>{\n            process = true;\n            // TODO: More tests for inline content slides\n            if ((0, $d8642219fb19b896$export$4ea3d958472af68f)(e.targetTouches[0].target, \"ginner-container\") || (0, $d8642219fb19b896$export$ff7f7c97cdce86e)(e.targetTouches[0].target, \".gslide-desc\") || e.targetTouches[0].target.nodeName.toLowerCase() == \"a\") process = false;\n            if ((0, $d8642219fb19b896$export$ff7f7c97cdce86e)(e.targetTouches[0].target, \".gslide-inline\") && !(0, $d8642219fb19b896$export$4ea3d958472af68f)(e.targetTouches[0].target.parentNode, \"gslide-inline\")) process = false;\n            if (process) {\n                endCoords = e.targetTouches[0];\n                startCoords.pageX = e.targetTouches[0].pageX;\n                startCoords.pageY = e.targetTouches[0].pageY;\n                xDown = e.targetTouches[0].clientX;\n                yDown = e.targetTouches[0].clientY;\n                currentSlide = instance.activeSlide;\n                media = currentSlide.querySelector(\".gslide-media\");\n                isInlined = currentSlide.querySelector(\".gslide-inline\");\n                mediaImage = null;\n                if ((0, $d8642219fb19b896$export$4ea3d958472af68f)(media, \"gslide-image\")) mediaImage = media.querySelector(\"img\");\n                const windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n                if (windowWidth > 769) media = currentSlide.querySelector(\".ginner-container\");\n                (0, $d8642219fb19b896$export$c2255604a80b4506)(overlay, \"greset\");\n                if (e.pageX > 20 && e.pageX < window.innerWidth - 20) return;\n                e.preventDefault();\n            }\n        },\n        touchMove: (e)=>{\n            if (!process) return;\n            endCoords = e.targetTouches[0];\n            if (doingZoom || imageZoomed) return;\n            if (isInlined && isInlined.offsetHeight > winHeight) {\n                // Allow scroll without moving the slide\n                const moved = startCoords.pageX - endCoords.pageX;\n                if (Math.abs(moved) <= 13) return false;\n            }\n            doingMove = true;\n            let xUp = e.targetTouches[0].clientX;\n            let yUp = e.targetTouches[0].clientY;\n            let xDiff = xDown - xUp;\n            let yDiff = yDown - yUp;\n            if (Math.abs(xDiff) > Math.abs(yDiff)) {\n                vSwipe = false;\n                hSwipe = true;\n            } else {\n                hSwipe = false;\n                vSwipe = true;\n            }\n            hDistance = endCoords.pageX - startCoords.pageX;\n            hDistancePercent = hDistance * 100 / winWidth;\n            vDistance = endCoords.pageY - startCoords.pageY;\n            vDistancePercent = vDistance * 100 / winHeight;\n            let opacity;\n            if (vSwipe && mediaImage) {\n                opacity = 1 - Math.abs(vDistance) / winHeight;\n                overlay.style.opacity = opacity;\n                if (instance.settings.touchFollowAxis) hDistancePercent = 0;\n            }\n            if (hSwipe) {\n                opacity = 1 - Math.abs(hDistance) / winWidth;\n                media.style.opacity = opacity;\n                if (instance.settings.touchFollowAxis) vDistancePercent = 0;\n            }\n            if (!mediaImage) return (0, $d8642219fb19b896$export$fd43050ca342497c)(media, `translate3d(${hDistancePercent}%, 0, 0)`);\n            (0, $d8642219fb19b896$export$fd43050ca342497c)(media, `translate3d(${hDistancePercent}%, ${vDistancePercent}%, 0)`);\n        },\n        touchEnd: ()=>{\n            if (!process) return;\n            doingMove = false;\n            if (imageZoomed || doingZoom) {\n                lastZoomedPosX = zoomedPosX;\n                lastZoomedPosY = zoomedPosY;\n                return;\n            }\n            const v = Math.abs(parseInt(vDistancePercent));\n            const h = Math.abs(parseInt(hDistancePercent));\n            if (v > 29 && mediaImage) {\n                instance.close();\n                return;\n            }\n            if (v < 29 && h < 25) {\n                (0, $d8642219fb19b896$export$d2cf6cd1dc7067d3)(overlay, \"greset\");\n                overlay.style.opacity = 1;\n                return $8cb9d8feeacb1ed6$var$resetSlideMove(media);\n            }\n        },\n        multipointEnd: ()=>{\n            setTimeout(()=>{\n                doingZoom = false;\n            }, 50);\n        },\n        multipointStart: ()=>{\n            doingZoom = true;\n            initScale = currentScale ? currentScale : 1;\n        },\n        pinch: (evt)=>{\n            if (!mediaImage || doingMove) return false;\n            doingZoom = true;\n            mediaImage.scaleX = mediaImage.scaleY = initScale * evt.zoom;\n            let scale = initScale * evt.zoom;\n            imageZoomed = true;\n            if (scale <= 1) {\n                imageZoomed = false;\n                scale = 1;\n                lastZoomedPosY = null;\n                lastZoomedPosX = null;\n                zoomedPosX = null;\n                zoomedPosY = null;\n                mediaImage.setAttribute(\"style\", \"\");\n                return;\n            }\n            if (scale > maxScale) // max scale zoom\n            scale = maxScale;\n            mediaImage.style.transform = `scale3d(${scale}, ${scale}, 1)`;\n            currentScale = scale;\n        },\n        pressMove: (e)=>{\n            if (imageZoomed && !doingZoom) {\n                var mhDistance = endCoords.pageX - startCoords.pageX;\n                var mvDistance = endCoords.pageY - startCoords.pageY;\n                if (lastZoomedPosX) mhDistance = mhDistance + lastZoomedPosX;\n                if (lastZoomedPosY) mvDistance = mvDistance + lastZoomedPosY;\n                zoomedPosX = mhDistance;\n                zoomedPosY = mvDistance;\n                let style = `translate3d(${mhDistance}px, ${mvDistance}px, 0)`;\n                if (currentScale) style += ` scale3d(${currentScale}, ${currentScale}, 1)`;\n                (0, $d8642219fb19b896$export$fd43050ca342497c)(mediaImage, style);\n            }\n        },\n        swipe: (evt)=>{\n            if (imageZoomed) return;\n            if (doingZoom) {\n                doingZoom = false;\n                return;\n            }\n            if (evt.direction == \"Left\") {\n                if (instance.index == instance.elements.length - 1) return $8cb9d8feeacb1ed6$var$resetSlideMove(media);\n                instance.nextSlide();\n            }\n            if (evt.direction == \"Right\") {\n                if (instance.index == 0) return $8cb9d8feeacb1ed6$var$resetSlideMove(media);\n                instance.prevSlide();\n            }\n        }\n    });\n    instance.events[\"touch\"] = touchInstance;\n}\n\n\n\nconst $81a53f2a460b34f6$var$version = \"3.3.0\";\nconst $81a53f2a460b34f6$var$isMobile = $d8642219fb19b896$export$d0a8044dce8ff2fc();\nconst $81a53f2a460b34f6$var$isTouch = $d8642219fb19b896$export$971e5333ff27c622();\nconst $81a53f2a460b34f6$var$html = document.getElementsByTagName(\"html\")[0];\nconst $81a53f2a460b34f6$var$defaults = {\n    selector: \".glightbox\",\n    elements: null,\n    skin: \"clean\",\n    theme: \"clean\",\n    closeButton: true,\n    startAt: null,\n    autoplayVideos: true,\n    autofocusVideos: true,\n    descPosition: \"bottom\",\n    width: \"900px\",\n    height: \"506px\",\n    videosWidth: \"960px\",\n    beforeSlideChange: null,\n    afterSlideChange: null,\n    beforeSlideLoad: null,\n    afterSlideLoad: null,\n    slideInserted: null,\n    slideRemoved: null,\n    slideExtraAttributes: null,\n    onOpen: null,\n    onClose: null,\n    loop: false,\n    zoomable: true,\n    draggable: true,\n    dragAutoSnap: false,\n    dragToleranceX: 40,\n    dragToleranceY: 65,\n    preload: true,\n    oneSlidePerOpen: false,\n    touchNavigation: true,\n    touchFollowAxis: true,\n    keyboardNavigation: true,\n    closeOnOutsideClick: true,\n    plugins: false,\n    plyr: {\n        css: \"https://cdn.plyr.io/3.6.12/plyr.css\",\n        js: \"https://cdn.plyr.io/3.6.12/plyr.js\",\n        config: {\n            ratio: \"16:9\",\n            fullscreen: {\n                enabled: true,\n                iosNative: true\n            },\n            youtube: {\n                noCookie: true,\n                rel: 0,\n                showinfo: 0,\n                iv_load_policy: 3 // eslint-disable-line camelcase\n            },\n            vimeo: {\n                byline: false,\n                portrait: false,\n                title: false,\n                transparent: false\n            }\n        }\n    },\n    openEffect: \"zoom\",\n    closeEffect: \"zoom\",\n    slideEffect: \"slide\",\n    moreText: \"See more\",\n    moreLength: 60,\n    cssEfects: {\n        fade: {\n            in: \"fadeIn\",\n            out: \"fadeOut\"\n        },\n        zoom: {\n            in: \"zoomIn\",\n            out: \"zoomOut\"\n        },\n        slide: {\n            in: \"slideInRight\",\n            out: \"slideOutLeft\"\n        },\n        slideBack: {\n            in: \"slideInLeft\",\n            out: \"slideOutRight\"\n        },\n        none: {\n            in: \"none\",\n            out: \"none\"\n        }\n    },\n    svg: {\n        close: '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 512 512\" xml:space=\"preserve\"><g><g><path d=\"M505.943,6.058c-8.077-8.077-21.172-8.077-29.249,0L6.058,476.693c-8.077,8.077-8.077,21.172,0,29.249C10.096,509.982,15.39,512,20.683,512c5.293,0,10.586-2.019,14.625-6.059L505.943,35.306C514.019,27.23,514.019,14.135,505.943,6.058z\"/></g></g><g><g><path d=\"M505.942,476.694L35.306,6.059c-8.076-8.077-21.172-8.077-29.248,0c-8.077,8.076-8.077,21.171,0,29.248l470.636,470.636c4.038,4.039,9.332,6.058,14.625,6.058c5.293,0,10.587-2.019,14.624-6.057C514.018,497.866,514.018,484.771,505.942,476.694z\"/></g></g></svg>',\n        next: '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 477.175 477.175\" xml:space=\"preserve\"> <g><path d=\"M360.731,229.075l-225.1-225.1c-5.3-5.3-13.8-5.3-19.1,0s-5.3,13.8,0,19.1l215.5,215.5l-215.5,215.5c-5.3,5.3-5.3,13.8,0,19.1c2.6,2.6,6.1,4,9.5,4c3.4,0,6.9-1.3,9.5-4l225.1-225.1C365.931,242.875,365.931,234.275,360.731,229.075z\"/></g></svg>',\n        prev: '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 477.175 477.175\" xml:space=\"preserve\"><g><path d=\"M145.188,238.575l215.5-215.5c5.3-5.3,5.3-13.8,0-19.1s-13.8-5.3-19.1,0l-225.1,225.1c-5.3,5.3-5.3,13.8,0,19.1l225.1,225c2.6,2.6,6.1,4,9.5,4s6.9-1.3,9.5-4c5.3-5.3,5.3-13.8,0-19.1L145.188,238.575z\"/></g></svg>'\n    }\n};\n// You can pass your own slide structure\n// just make sure that add the same classes so they are populated\n// title class = gslide-title\n// desc class = gslide-desc\n// prev arrow class = gnext\n// next arrow id = gprev\n// close id = gclose\n$81a53f2a460b34f6$var$defaults.slideHTML = `<div class=\"gslide\">\n    <div class=\"gslide-inner-content\">\n        <div class=\"ginner-container\">\n            <div class=\"gslide-media\">\n            </div>\n            <div class=\"gslide-description\">\n                <div class=\"gdesc-inner\">\n                    <h4 class=\"gslide-title\"></h4>\n                    <div class=\"gslide-desc\"></div>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>`;\n$81a53f2a460b34f6$var$defaults.lightboxHTML = `<div id=\"glightbox-body\" class=\"glightbox-container\" tabindex=\"-1\" role=\"dialog\" aria-hidden=\"false\">\n    <div class=\"gloader visible\"></div>\n    <div class=\"goverlay\"></div>\n    <div class=\"gcontainer\">\n    <div id=\"glightbox-slider\" class=\"gslider\"></div>\n    <button class=\"gclose gbtn\" aria-label=\"Close\" data-taborder=\"3\">{closeSVG}</button>\n    <button class=\"gprev gbtn\" aria-label=\"Previous\" data-taborder=\"2\">{prevSVG}</button>\n    <button class=\"gnext gbtn\" aria-label=\"Next\" data-taborder=\"1\">{nextSVG}</button>\n</div>\n</div>`;\n/**\n * GLightbox Class\n * Class and public methods\n */ class $81a53f2a460b34f6$var$GlightboxInit {\n    constructor(options = {}){\n        this.customOptions = options;\n        this.settings = $d8642219fb19b896$export$8b58be045bf06082($81a53f2a460b34f6$var$defaults, options);\n        this.effectsClasses = this.getAnimationClasses();\n        this.videoPlayers = {};\n        this.apiEvents = [];\n        this.fullElementsList = false;\n    }\n    init() {\n        const selector = this.getSelector();\n        if (selector) this.baseEvents = $d8642219fb19b896$export$f531f92e2a15358f(\"click\", {\n            onElement: selector,\n            withCallback: (e, target)=>{\n                e.preventDefault();\n                this.open(target);\n            }\n        });\n        this.elements = this.getElements();\n    }\n    open(element = null, startAt = null) {\n        if (this.elements.length === 0) return false;\n        this.activeSlide = null;\n        this.prevActiveSlideIndex = null;\n        this.prevActiveSlide = null;\n        let index = $d8642219fb19b896$export$7e4aa119212bc614(startAt) ? startAt : this.settings.startAt;\n        if ($d8642219fb19b896$export$8ee0fc9ee280b4ee(element)) {\n            const gallery = element.getAttribute(\"data-gallery\");\n            if (gallery) {\n                this.fullElementsList = this.elements;\n                this.elements = this.getGalleryElements(this.elements, gallery);\n            }\n            if ($d8642219fb19b896$export$984f70f9382f5d27(index)) {\n                // get the index of the element\n                index = this.getElementIndex(element);\n                if (index < 0) index = 0;\n            }\n        }\n        if (!$d8642219fb19b896$export$7e4aa119212bc614(index)) index = 0;\n        this.build();\n        $d8642219fb19b896$export$5ed9d0a3cf9b0f86(this.overlay, this.settings.openEffect === \"none\" ? \"none\" : this.settings.cssEfects.fade.in);\n        const body = document.body;\n        const scrollBar = window.innerWidth - document.documentElement.clientWidth;\n        if (scrollBar > 0) {\n            var styleSheet = document.createElement(\"style\");\n            styleSheet.type = \"text/css\";\n            styleSheet.className = \"gcss-styles\";\n            styleSheet.innerText = `.gscrollbar-fixer {margin-right: ${scrollBar}px}`;\n            document.head.appendChild(styleSheet);\n            $d8642219fb19b896$export$d2cf6cd1dc7067d3(body, \"gscrollbar-fixer\");\n        }\n        $d8642219fb19b896$export$d2cf6cd1dc7067d3(body, \"glightbox-open\");\n        $d8642219fb19b896$export$d2cf6cd1dc7067d3($81a53f2a460b34f6$var$html, \"glightbox-open\");\n        if ($81a53f2a460b34f6$var$isMobile) {\n            $d8642219fb19b896$export$d2cf6cd1dc7067d3(document.body, \"glightbox-mobile\");\n            this.settings.slideEffect = \"slide\";\n        }\n        this.showSlide(index, true);\n        if (this.elements.length === 1) {\n            $d8642219fb19b896$export$d2cf6cd1dc7067d3(this.prevButton, \"glightbox-button-hidden\");\n            $d8642219fb19b896$export$d2cf6cd1dc7067d3(this.nextButton, \"glightbox-button-hidden\");\n        } else {\n            $d8642219fb19b896$export$c2255604a80b4506(this.prevButton, \"glightbox-button-hidden\");\n            $d8642219fb19b896$export$c2255604a80b4506(this.nextButton, \"glightbox-button-hidden\");\n        }\n        this.lightboxOpen = true;\n        this.trigger(\"open\");\n        // settings.onOpen is deprecated and will be removed in a future update\n        if ($d8642219fb19b896$export$f6e2535fb5126e54(this.settings.onOpen)) this.settings.onOpen();\n        if ($81a53f2a460b34f6$var$isTouch && this.settings.touchNavigation) (0, $8cb9d8feeacb1ed6$export$2e2bcd8739ae039)(this);\n        if (this.settings.keyboardNavigation) (0, $7eef44a6201db4db$export$2e2bcd8739ae039)(this);\n    }\n    /**\n     * Open at specific index\n     * @param {int} index\n     */ openAt(index = 0) {\n        this.open(null, index);\n    }\n    /**\n     * Set Slide\n     */ showSlide(index = 0, first = false) {\n        $d8642219fb19b896$export$57bf213be019eeb0(this.loader);\n        this.index = parseInt(index);\n        let current = this.slidesContainer.querySelector(\".current\");\n        if (current) $d8642219fb19b896$export$c2255604a80b4506(current, \"current\");\n        // hide prev slide\n        this.slideAnimateOut();\n        let slideNode = this.slidesContainer.querySelectorAll(\".gslide\")[index];\n        // Check if slide's content is alreay loaded\n        if ($d8642219fb19b896$export$4ea3d958472af68f(slideNode, \"loaded\")) {\n            this.slideAnimateIn(slideNode, first);\n            $d8642219fb19b896$export$fe8985bb6374093c(this.loader);\n        } else {\n            // If not loaded add the slide content\n            $d8642219fb19b896$export$57bf213be019eeb0(this.loader);\n            const slide = this.elements[index];\n            const slideData = {\n                index: this.index,\n                slide: slideNode,\n                slideNode: slideNode,\n                slideConfig: slide.slideConfig,\n                slideIndex: this.index,\n                trigger: slide.node,\n                player: null\n            };\n            this.trigger(\"slide_before_load\", slideData);\n            slide.instance.setContent(slideNode, ()=>{\n                $d8642219fb19b896$export$fe8985bb6374093c(this.loader);\n                this.resize();\n                this.slideAnimateIn(slideNode, first);\n                this.trigger(\"slide_after_load\", slideData);\n            });\n        }\n        this.slideDescription = slideNode.querySelector(\".gslide-description\");\n        this.slideDescriptionContained = this.slideDescription && $d8642219fb19b896$export$4ea3d958472af68f(this.slideDescription.parentNode, \"gslide-media\");\n        // Preload subsequent slides\n        if (this.settings.preload) {\n            this.preloadSlide(index + 1);\n            this.preloadSlide(index - 1);\n        }\n        // Handle navigation arrows\n        this.updateNavigationClasses();\n        this.activeSlide = slideNode;\n    }\n    /**\n     * Preload slides\n     * @param  {Int}  index slide index\n     * @return {null}\n     */ preloadSlide(index) {\n        // Verify slide index, it can not be lower than 0\n        // and it can not be greater than the total elements\n        if (index < 0 || index > this.elements.length - 1) return false;\n        if ($d8642219fb19b896$export$984f70f9382f5d27(this.elements[index])) return false;\n        let slideNode = this.slidesContainer.querySelectorAll(\".gslide\")[index];\n        if ($d8642219fb19b896$export$4ea3d958472af68f(slideNode, \"loaded\")) return false;\n        const slide = this.elements[index];\n        const type = slide.type;\n        const slideData = {\n            index: index,\n            slide: slideNode,\n            slideNode: slideNode,\n            slideConfig: slide.slideConfig,\n            slideIndex: index,\n            trigger: slide.node,\n            player: null\n        };\n        this.trigger(\"slide_before_load\", slideData);\n        if (type === \"video\" || type === \"external\") setTimeout(()=>{\n            slide.instance.setContent(slideNode, ()=>{\n                this.trigger(\"slide_after_load\", slideData);\n            });\n        }, 200);\n        else slide.instance.setContent(slideNode, ()=>{\n            this.trigger(\"slide_after_load\", slideData);\n        });\n    }\n    /**\n     * Load previous slide\n     * calls goToslide\n     */ prevSlide() {\n        this.goToSlide(this.index - 1);\n    }\n    /**\n     * Load next slide\n     * calls goToslide\n     */ nextSlide() {\n        this.goToSlide(this.index + 1);\n    }\n    /**\n     * Go to sldei\n     * calls set slide\n     * @param {Int} - index\n     */ goToSlide(index = false) {\n        this.prevActiveSlide = this.activeSlide;\n        this.prevActiveSlideIndex = this.index;\n        if (!this.loop() && (index < 0 || index > this.elements.length - 1)) return false;\n        if (index < 0) index = this.elements.length - 1;\n        else if (index >= this.elements.length) index = 0;\n        this.showSlide(index);\n    }\n    /**\n     * Insert slide\n     *\n     * @param { object } data\n     * @param { numeric } position\n     */ insertSlide(config = {}, index = -1) {\n        // Append at the end\n        if (index < 0) index = this.elements.length;\n        const slide = new (0, $b1ff45689b2e6929$export$2e2bcd8739ae039)(config, this, index);\n        const data = slide.getConfig();\n        const slideInfo = $d8642219fb19b896$export$8b58be045bf06082({}, data);\n        const newSlide = slide.create();\n        const totalSlides = this.elements.length - 1;\n        slideInfo.index = index;\n        slideInfo.node = false;\n        slideInfo.instance = slide;\n        slideInfo.slideConfig = data;\n        this.elements.splice(index, 0, slideInfo);\n        let addedSlideNode = null;\n        let addedSlidePlayer = null;\n        if (this.slidesContainer) {\n            // Append at the end\n            if (index > totalSlides) this.slidesContainer.appendChild(newSlide);\n            else {\n                // A current slide must exist in the position specified\n                // we need tp get that slide and insder the new slide before\n                let existingSlide = this.slidesContainer.querySelectorAll(\".gslide\")[index];\n                this.slidesContainer.insertBefore(newSlide, existingSlide);\n            }\n            if (this.settings.preload && this.index == 0 && index == 0 || this.index - 1 == index || this.index + 1 == index) this.preloadSlide(index);\n            if (this.index === 0 && index === 0) this.index = 1;\n            this.updateNavigationClasses();\n            addedSlideNode = this.slidesContainer.querySelectorAll(\".gslide\")[index];\n            addedSlidePlayer = this.getSlidePlayerInstance(index);\n            slideInfo.slideNode = addedSlideNode;\n        }\n        this.trigger(\"slide_inserted\", {\n            index: index,\n            slide: addedSlideNode,\n            slideNode: addedSlideNode,\n            slideConfig: data,\n            slideIndex: index,\n            trigger: null,\n            player: addedSlidePlayer\n        });\n        // Deprecated and will be removed in a future update\n        if ($d8642219fb19b896$export$f6e2535fb5126e54(this.settings.slideInserted)) this.settings.slideInserted({\n            index: index,\n            slide: addedSlideNode,\n            player: addedSlidePlayer\n        });\n    }\n    /**\n     * Remove slide\n     *\n     * @param { numeric } position\n     */ removeSlide(index = -1) {\n        if (index < 0 || index > this.elements.length - 1) return false;\n        const slide = this.slidesContainer && this.slidesContainer.querySelectorAll(\".gslide\")[index];\n        if (slide) {\n            if (this.getActiveSlideIndex() == index) {\n                if (index == this.elements.length - 1) this.prevSlide();\n                else this.nextSlide();\n            }\n            slide.parentNode.removeChild(slide);\n        }\n        this.elements.splice(index, 1);\n        this.trigger(\"slide_removed\", index);\n        // Deprecated and will be removed in a future update\n        if ($d8642219fb19b896$export$f6e2535fb5126e54(this.settings.slideRemoved)) this.settings.slideRemoved(index);\n    }\n    /**\n     * Slide In\n     * @return {null}\n     */ slideAnimateIn(slide, first) {\n        let slideMedia = slide.querySelector(\".gslide-media\");\n        let slideDesc = slide.querySelector(\".gslide-description\");\n        let prevData = {\n            index: this.prevActiveSlideIndex,\n            slide: this.prevActiveSlide,\n            slideNode: this.prevActiveSlide,\n            slideIndex: this.prevActiveSlide,\n            slideConfig: $d8642219fb19b896$export$984f70f9382f5d27(this.prevActiveSlideIndex) ? null : this.elements[this.prevActiveSlideIndex].slideConfig,\n            trigger: $d8642219fb19b896$export$984f70f9382f5d27(this.prevActiveSlideIndex) ? null : this.elements[this.prevActiveSlideIndex].node,\n            player: this.getSlidePlayerInstance(this.prevActiveSlideIndex)\n        };\n        let nextData = {\n            index: this.index,\n            slide: this.activeSlide,\n            slideNode: this.activeSlide,\n            slideConfig: this.elements[this.index].slideConfig,\n            slideIndex: this.index,\n            trigger: this.elements[this.index].node,\n            player: this.getSlidePlayerInstance(this.index)\n        };\n        if (slideMedia.offsetWidth > 0 && slideDesc) {\n            $d8642219fb19b896$export$fe8985bb6374093c(slideDesc);\n            slideDesc.style.display = \"\";\n        }\n        $d8642219fb19b896$export$c2255604a80b4506(slide, this.effectsClasses);\n        if (first) $d8642219fb19b896$export$5ed9d0a3cf9b0f86(slide, this.settings.cssEfects[this.settings.openEffect].in, ()=>{\n            if (this.settings.autoplayVideos) this.slidePlayerPlay(slide);\n            this.trigger(\"slide_changed\", {\n                prev: prevData,\n                current: nextData\n            });\n            // settings.afterSlideChange is deprecated and will be removed in a future update\n            if ($d8642219fb19b896$export$f6e2535fb5126e54(this.settings.afterSlideChange)) this.settings.afterSlideChange.apply(this, [\n                prevData,\n                nextData\n            ]);\n        });\n        else {\n            let effectName = this.settings.slideEffect;\n            let animIn = effectName !== \"none\" ? this.settings.cssEfects[effectName].in : effectName;\n            if (this.prevActiveSlideIndex > this.index) {\n                if (this.settings.slideEffect == \"slide\") animIn = this.settings.cssEfects.slideBack.in;\n            }\n            $d8642219fb19b896$export$5ed9d0a3cf9b0f86(slide, animIn, ()=>{\n                if (this.settings.autoplayVideos) this.slidePlayerPlay(slide);\n                this.trigger(\"slide_changed\", {\n                    prev: prevData,\n                    current: nextData\n                });\n                // settings.afterSlideChange is deprecated and will be removed in a future update\n                if ($d8642219fb19b896$export$f6e2535fb5126e54(this.settings.afterSlideChange)) this.settings.afterSlideChange.apply(this, [\n                    prevData,\n                    nextData\n                ]);\n            });\n        }\n        setTimeout(()=>{\n            this.resize(slide);\n        }, 100);\n        $d8642219fb19b896$export$d2cf6cd1dc7067d3(slide, \"current\");\n    }\n    /**\n     * Slide out\n     */ slideAnimateOut() {\n        if (!this.prevActiveSlide) return false;\n        let prevSlide = this.prevActiveSlide;\n        $d8642219fb19b896$export$c2255604a80b4506(prevSlide, this.effectsClasses);\n        $d8642219fb19b896$export$d2cf6cd1dc7067d3(prevSlide, \"prev\");\n        let animation = this.settings.slideEffect;\n        let animOut = animation !== \"none\" ? this.settings.cssEfects[animation].out : animation;\n        this.slidePlayerPause(prevSlide);\n        this.trigger(\"slide_before_change\", {\n            prev: {\n                index: this.prevActiveSlideIndex,\n                slide: this.prevActiveSlide,\n                slideNode: this.prevActiveSlide,\n                slideIndex: this.prevActiveSlideIndex,\n                slideConfig: $d8642219fb19b896$export$984f70f9382f5d27(this.prevActiveSlideIndex) ? null : this.elements[this.prevActiveSlideIndex].slideConfig,\n                trigger: $d8642219fb19b896$export$984f70f9382f5d27(this.prevActiveSlideIndex) ? null : this.elements[this.prevActiveSlideIndex].node,\n                player: this.getSlidePlayerInstance(this.prevActiveSlideIndex)\n            },\n            current: {\n                index: this.index,\n                slide: this.activeSlide,\n                slideNode: this.activeSlide,\n                slideIndex: this.index,\n                slideConfig: this.elements[this.index].slideConfig,\n                trigger: this.elements[this.index].node,\n                player: this.getSlidePlayerInstance(this.index)\n            }\n        });\n        // settings.beforeSlideChange is deprecated and will be removed in a future update\n        if ($d8642219fb19b896$export$f6e2535fb5126e54(this.settings.beforeSlideChange)) this.settings.beforeSlideChange.apply(this, [\n            {\n                index: this.prevActiveSlideIndex,\n                slide: this.prevActiveSlide,\n                player: this.getSlidePlayerInstance(this.prevActiveSlideIndex)\n            },\n            {\n                index: this.index,\n                slide: this.activeSlide,\n                player: this.getSlidePlayerInstance(this.index)\n            }\n        ]);\n        if (this.prevActiveSlideIndex > this.index && this.settings.slideEffect == \"slide\") // going back\n        animOut = this.settings.cssEfects.slideBack.out;\n        $d8642219fb19b896$export$5ed9d0a3cf9b0f86(prevSlide, animOut, ()=>{\n            let container = prevSlide.querySelector(\".ginner-container\");\n            let media = prevSlide.querySelector(\".gslide-media\");\n            let desc = prevSlide.querySelector(\".gslide-description\");\n            container.style.transform = \"\";\n            media.style.transform = \"\";\n            $d8642219fb19b896$export$c2255604a80b4506(media, \"greset\");\n            media.style.opacity = \"\";\n            if (desc) desc.style.opacity = \"\";\n            $d8642219fb19b896$export$c2255604a80b4506(prevSlide, \"prev\");\n        });\n    }\n    /**\n     * Get all defined players\n     */ getAllPlayers() {\n        return this.videoPlayers;\n    }\n    /**\n     * Get player at index\n     *\n     * @param index\n     * @return bool|object\n     */ getSlidePlayerInstance(index) {\n        const id = \"gvideo\" + index;\n        const videoPlayers = this.getAllPlayers();\n        if ($d8642219fb19b896$export$a4f4bb6b1453fff5(videoPlayers, id) && videoPlayers[id]) return videoPlayers[id];\n        return false;\n    }\n    /**\n     * Stop video at specified\n     * node or index\n     *\n     * @param slide node or index\n     * @return void\n     */ stopSlideVideo(slide) {\n        if ($d8642219fb19b896$export$8ee0fc9ee280b4ee(slide)) {\n            let node = slide.querySelector(\".gvideo-wrapper\");\n            if (node) slide = node.getAttribute(\"data-index\");\n        }\n        console.log(\"stopSlideVideo is deprecated, use slidePlayerPause\");\n        const player = this.getSlidePlayerInstance(slide);\n        if (player && player.playing) player.pause();\n    }\n    /**\n     * Stop player at specified index\n     *\n     * @param slide node or index\n     * @return void\n     */ slidePlayerPause(slide) {\n        if ($d8642219fb19b896$export$8ee0fc9ee280b4ee(slide)) {\n            let node = slide.querySelector(\".gvideo-wrapper\");\n            if (node) slide = node.getAttribute(\"data-index\");\n        }\n        const player = this.getSlidePlayerInstance(slide);\n        if (player && player.playing) player.pause();\n    }\n    /**\n     * Play video at specified\n     * node or index\n     *\n     * @param slide node or index\n     * @return void\n     */ playSlideVideo(slide) {\n        if ($d8642219fb19b896$export$8ee0fc9ee280b4ee(slide)) {\n            let node = slide.querySelector(\".gvideo-wrapper\");\n            if (node) slide = node.getAttribute(\"data-index\");\n        }\n        console.log(\"playSlideVideo is deprecated, use slidePlayerPlay\");\n        const player = this.getSlidePlayerInstance(slide);\n        if (player && !player.playing) player.play();\n    }\n    /**\n     * Play media player at specified\n     * node or index\n     *\n     * @param slide node or index\n     * @return void\n     */ slidePlayerPlay(slide) {\n        // Do not autoplay on mobile\n        // plyr does not handle well the errors\n        // and the player becomes unplayable\n        if ($81a53f2a460b34f6$var$isMobile && !this.settings.plyr.config?.muted) return;\n        if ($d8642219fb19b896$export$8ee0fc9ee280b4ee(slide)) {\n            let node = slide.querySelector(\".gvideo-wrapper\");\n            if (node) slide = node.getAttribute(\"data-index\");\n        }\n        const player = this.getSlidePlayerInstance(slide);\n        if (player && !player.playing) {\n            player.play();\n            if (this.settings.autofocusVideos) player.elements.container.focus();\n        }\n    }\n    /**\n     * Set the entire elements\n     * in the gallery, it replaces all\n     * the existing elements\n     * with the specified list\n     *\n     * @param {array}  elements\n     */ setElements(elements) {\n        this.settings.elements = false;\n        const newElements = [];\n        if (elements && elements.length) $d8642219fb19b896$export$79b2f7037acddd43(elements, (el, i)=>{\n            const slide = new (0, $b1ff45689b2e6929$export$2e2bcd8739ae039)(el, this, i);\n            const data = slide.getConfig();\n            const slideInfo = $d8642219fb19b896$export$8b58be045bf06082({}, data);\n            slideInfo.slideConfig = data;\n            slideInfo.instance = slide;\n            slideInfo.index = i;\n            newElements.push(slideInfo);\n        });\n        this.elements = newElements;\n        if (this.lightboxOpen) {\n            this.slidesContainer.innerHTML = \"\";\n            if (this.elements.length) {\n                $d8642219fb19b896$export$79b2f7037acddd43(this.elements, ()=>{\n                    let slide = $d8642219fb19b896$export$8062c7bb2dbf069a(this.settings.slideHTML);\n                    this.slidesContainer.appendChild(slide);\n                });\n                this.showSlide(0, true);\n            }\n        }\n    }\n    /**\n     * Return the index\n     * of the specified node,\n     * this node is for example an image, link, etc.\n     * that when clicked it opens the lightbox\n     * its position in the elements array can change\n     * when using insertSlide or removeSlide so we\n     * need to find it in the elements list\n     *\n     * @param {node} node\n     * @return bool|int\n     */ getElementIndex(node) {\n        let index = false;\n        $d8642219fb19b896$export$79b2f7037acddd43(this.elements, (el, i)=>{\n            if ($d8642219fb19b896$export$a4f4bb6b1453fff5(el, \"node\") && el.node == node) {\n                index = i;\n                return true; // exit loop\n            }\n        });\n        return index;\n    }\n    /**\n     * Get elements\n     * returns an array containing all\n     * the elements that must be displayed in the\n     * lightbox\n     *\n     * @return { array }\n     */ getElements() {\n        let list = [];\n        this.elements = this.elements ? this.elements : [];\n        if (!$d8642219fb19b896$export$984f70f9382f5d27(this.settings.elements) && $d8642219fb19b896$export$43bee75e5e14138e(this.settings.elements) && this.settings.elements.length) $d8642219fb19b896$export$79b2f7037acddd43(this.settings.elements, (el, i)=>{\n            const slide = new (0, $b1ff45689b2e6929$export$2e2bcd8739ae039)(el, this, i);\n            const elData = slide.getConfig();\n            const slideInfo = $d8642219fb19b896$export$8b58be045bf06082({}, elData);\n            slideInfo.node = false;\n            slideInfo.index = i;\n            slideInfo.instance = slide;\n            slideInfo.slideConfig = elData;\n            list.push(slideInfo);\n        });\n        let nodes = false;\n        let selector = this.getSelector();\n        if (selector) nodes = document.querySelectorAll(this.getSelector());\n        if (!nodes) return list;\n        $d8642219fb19b896$export$79b2f7037acddd43(nodes, (el, i)=>{\n            const slide = new (0, $b1ff45689b2e6929$export$2e2bcd8739ae039)(el, this, i);\n            const elData = slide.getConfig();\n            const slideInfo = $d8642219fb19b896$export$8b58be045bf06082({}, elData);\n            slideInfo.node = el;\n            slideInfo.index = i;\n            slideInfo.instance = slide;\n            slideInfo.slideConfig = elData;\n            slideInfo.gallery = el.getAttribute(\"data-gallery\");\n            list.push(slideInfo);\n        });\n        return list;\n    }\n    /**\n     * Return only the elements\n     * from a specific gallery\n     *\n     * @return array\n     */ getGalleryElements(list, gallery) {\n        return list.filter((el)=>{\n            return el.gallery == gallery;\n        });\n    }\n    /**\n     * Get selector\n     */ getSelector() {\n        if (this.settings.elements) return false;\n        if (this.settings.selector && this.settings.selector.substring(0, 5) == \"data-\") return `*[${this.settings.selector}]`;\n        return this.settings.selector;\n    }\n    /**\n     * Get the active slide\n     */ getActiveSlide() {\n        return this.slidesContainer.querySelectorAll(\".gslide\")[this.index];\n    }\n    /**\n     * Get the active index\n     */ getActiveSlideIndex() {\n        return this.index;\n    }\n    /**\n     * Get the defined\n     * effects as string\n     */ getAnimationClasses() {\n        let effects = [];\n        for(let key in this.settings.cssEfects)if (this.settings.cssEfects.hasOwnProperty(key)) {\n            let effect = this.settings.cssEfects[key];\n            effects.push(`g${effect.in}`);\n            effects.push(`g${effect.out}`);\n        }\n        return effects.join(\" \");\n    }\n    /**\n     * Build the structure\n     * @return {null}\n     */ build() {\n        if (this.built) return false;\n        // TODO: :scope is not supported on IE or first Edge. so we'll\n        // update this when IE support is removed to use newer code\n        //const children = document.body.querySelectorAll(':scope > *');\n        const children = document.body.childNodes;\n        const bodyChildElms = [];\n        $d8642219fb19b896$export$79b2f7037acddd43(children, (el)=>{\n            if (el.parentNode == document.body && el.nodeName.charAt(0) !== \"#\" && el.hasAttribute && !el.hasAttribute(\"aria-hidden\")) {\n                bodyChildElms.push(el);\n                el.setAttribute(\"aria-hidden\", \"true\");\n            }\n        });\n        const nextSVG = $d8642219fb19b896$export$a4f4bb6b1453fff5(this.settings.svg, \"next\") ? this.settings.svg.next : \"\";\n        const prevSVG = $d8642219fb19b896$export$a4f4bb6b1453fff5(this.settings.svg, \"prev\") ? this.settings.svg.prev : \"\";\n        const closeSVG = $d8642219fb19b896$export$a4f4bb6b1453fff5(this.settings.svg, \"close\") ? this.settings.svg.close : \"\";\n        let lightboxHTML = this.settings.lightboxHTML;\n        lightboxHTML = lightboxHTML.replace(/{nextSVG}/g, nextSVG);\n        lightboxHTML = lightboxHTML.replace(/{prevSVG}/g, prevSVG);\n        lightboxHTML = lightboxHTML.replace(/{closeSVG}/g, closeSVG);\n        lightboxHTML = $d8642219fb19b896$export$8062c7bb2dbf069a(lightboxHTML);\n        document.body.appendChild(lightboxHTML);\n        const modal = document.getElementById(\"glightbox-body\");\n        this.modal = modal;\n        let closeButton = modal.querySelector(\".gclose\");\n        this.prevButton = modal.querySelector(\".gprev\");\n        this.nextButton = modal.querySelector(\".gnext\");\n        this.overlay = modal.querySelector(\".goverlay\");\n        this.loader = modal.querySelector(\".gloader\");\n        this.slidesContainer = document.getElementById(\"glightbox-slider\");\n        this.bodyHiddenChildElms = bodyChildElms;\n        this.events = {};\n        $d8642219fb19b896$export$d2cf6cd1dc7067d3(this.modal, \"glightbox-\" + this.settings.skin);\n        if (this.settings.closeButton && closeButton) this.events[\"close\"] = $d8642219fb19b896$export$f531f92e2a15358f(\"click\", {\n            onElement: closeButton,\n            withCallback: (e, target)=>{\n                e.preventDefault();\n                this.close();\n            }\n        });\n        if (closeButton && !this.settings.closeButton) closeButton.parentNode.removeChild(closeButton);\n        if (this.nextButton) this.events[\"next\"] = $d8642219fb19b896$export$f531f92e2a15358f(\"click\", {\n            onElement: this.nextButton,\n            withCallback: (e, target)=>{\n                e.preventDefault();\n                this.nextSlide();\n            }\n        });\n        if (this.prevButton) this.events[\"prev\"] = $d8642219fb19b896$export$f531f92e2a15358f(\"click\", {\n            onElement: this.prevButton,\n            withCallback: (e, target)=>{\n                e.preventDefault();\n                this.prevSlide();\n            }\n        });\n        if (this.settings.closeOnOutsideClick) this.events[\"outClose\"] = $d8642219fb19b896$export$f531f92e2a15358f(\"click\", {\n            onElement: modal,\n            withCallback: (e, target)=>{\n                if (!this.preventOutsideClick && !$d8642219fb19b896$export$4ea3d958472af68f(document.body, \"glightbox-mobile\") && !$d8642219fb19b896$export$ff7f7c97cdce86e(e.target, \".ginner-container\")) {\n                    if (!$d8642219fb19b896$export$ff7f7c97cdce86e(e.target, \".gbtn\") && !$d8642219fb19b896$export$4ea3d958472af68f(e.target, \"gnext\") && !$d8642219fb19b896$export$4ea3d958472af68f(e.target, \"gprev\")) this.close();\n                }\n            }\n        });\n        $d8642219fb19b896$export$79b2f7037acddd43(this.elements, (slide, i)=>{\n            this.slidesContainer.appendChild(slide.instance.create());\n            slide.slideNode = this.slidesContainer.querySelectorAll(\".gslide\")[i];\n        });\n        if ($81a53f2a460b34f6$var$isTouch) $d8642219fb19b896$export$d2cf6cd1dc7067d3(document.body, \"glightbox-touch\");\n        this.events[\"resize\"] = $d8642219fb19b896$export$f531f92e2a15358f(\"resize\", {\n            onElement: window,\n            withCallback: ()=>{\n                this.resize();\n            }\n        });\n        this.built = true;\n    }\n    /**\n     * Handle resize\n     * Create only to handle\n     * when the height of the screen\n     * is lower than the slide content\n     * this helps to resize videos vertically\n     * and images with description\n     */ resize(slide = null) {\n        slide = !slide ? this.activeSlide : slide;\n        if (!slide || $d8642219fb19b896$export$4ea3d958472af68f(slide, \"zoomed\")) return;\n        const winSize = $d8642219fb19b896$export$994b0103697d2bf();\n        const video = slide.querySelector(\".gvideo-wrapper\");\n        const image = slide.querySelector(\".gslide-image\");\n        const description = this.slideDescription;\n        let winWidth = winSize.width;\n        let winHeight = winSize.height;\n        if (winWidth <= 768) $d8642219fb19b896$export$d2cf6cd1dc7067d3(document.body, \"glightbox-mobile\");\n        else $d8642219fb19b896$export$c2255604a80b4506(document.body, \"glightbox-mobile\");\n        if (!video && !image) return;\n        let descriptionResize = false;\n        if (description && ($d8642219fb19b896$export$4ea3d958472af68f(description, \"description-bottom\") || $d8642219fb19b896$export$4ea3d958472af68f(description, \"description-top\")) && !$d8642219fb19b896$export$4ea3d958472af68f(description, \"gabsolute\")) descriptionResize = true;\n        if (image) {\n            if (winWidth <= 768) {\n                let imgNode = image.querySelector(\"img\");\n            //imgNode.setAttribute('style', '');\n            } else if (descriptionResize) {\n                let descHeight = description.offsetHeight;\n                let imgNode = image.querySelector(\"img\");\n                // if a slide height is set via data-height, we want to use that\n                // if not, we fall back to 100vh\n                const slideTriggerNode = this.elements[this.index].node;\n                const maxHeightValue = slideTriggerNode.getAttribute(\"data-height\") ?? \"100vh\";\n                imgNode.setAttribute(\"style\", `max-height: calc(${maxHeightValue} - ${descHeight}px)`);\n                description.setAttribute(\"style\", `max-width: ${imgNode.offsetWidth}px;`);\n            }\n        }\n        if (video) {\n            let ratio = $d8642219fb19b896$export$a4f4bb6b1453fff5(this.settings.plyr.config, \"ratio\") ? this.settings.plyr.config.ratio : \"\";\n            if (!ratio) {\n                // If no ratio passed, calculate it using the video width and height\n                // generated by Plyr\n                const containerWidth = video.clientWidth;\n                const containerHeight = video.clientHeight;\n                const divisor = containerWidth / containerHeight;\n                ratio = `${containerWidth / divisor}:${containerHeight / divisor}`;\n            }\n            let videoRatio = ratio.split(\":\");\n            let videoWidth = this.settings.videosWidth;\n            let maxWidth = this.settings.videosWidth;\n            if ($d8642219fb19b896$export$7e4aa119212bc614(videoWidth) || videoWidth.indexOf(\"px\") !== -1) maxWidth = parseInt(videoWidth);\n            else {\n                // If video size is vw, vh or % convert it to pixels,\n                // fallback to the current video size\n                if (videoWidth.indexOf(\"vw\") !== -1) maxWidth = winWidth * parseInt(videoWidth) / 100;\n                else if (videoWidth.indexOf(\"vh\") !== -1) maxWidth = winHeight * parseInt(videoWidth) / 100;\n                else if (videoWidth.indexOf(\"%\") !== -1) maxWidth = winWidth * parseInt(videoWidth) / 100;\n                else maxWidth = parseInt(video.clientWidth);\n            }\n            let maxHeight = maxWidth / (parseInt(videoRatio[0]) / parseInt(videoRatio[1]));\n            maxHeight = Math.floor(maxHeight);\n            if (descriptionResize) winHeight = winHeight - description.offsetHeight;\n            if (maxWidth > winWidth || maxHeight > winHeight || winHeight < maxHeight && winWidth > maxWidth) {\n                let vwidth = video.offsetWidth;\n                let vheight = video.offsetHeight;\n                let ratio = winHeight / vheight;\n                let vsize = {\n                    width: vwidth * ratio,\n                    height: vheight * ratio\n                };\n                video.parentNode.setAttribute(\"style\", `max-width: ${vsize.width}px`);\n                if (descriptionResize) description.setAttribute(\"style\", `max-width: ${vsize.width}px;`);\n            } else {\n                video.parentNode.style.maxWidth = `${videoWidth}`;\n                if (descriptionResize) description.setAttribute(\"style\", `max-width: ${videoWidth};`);\n            }\n        }\n    }\n    /**\n     * Reload Lightbox\n     * reload and apply events to nodes\n     */ reload() {\n        this.init();\n    }\n    /**\n     * Update navigation classes on slide change\n     */ updateNavigationClasses() {\n        const loop = this.loop();\n        // Handle navigation arrows\n        $d8642219fb19b896$export$c2255604a80b4506(this.nextButton, \"disabled\");\n        $d8642219fb19b896$export$c2255604a80b4506(this.prevButton, \"disabled\");\n        if (this.index == 0 && this.elements.length - 1 == 0) {\n            $d8642219fb19b896$export$d2cf6cd1dc7067d3(this.prevButton, \"disabled\");\n            $d8642219fb19b896$export$d2cf6cd1dc7067d3(this.nextButton, \"disabled\");\n        } else if (this.index === 0 && !loop) $d8642219fb19b896$export$d2cf6cd1dc7067d3(this.prevButton, \"disabled\");\n        else if (this.index === this.elements.length - 1 && !loop) $d8642219fb19b896$export$d2cf6cd1dc7067d3(this.nextButton, \"disabled\");\n    }\n    /**\n     * Handle loop config\n     */ loop() {\n        let loop = $d8642219fb19b896$export$a4f4bb6b1453fff5(this.settings, \"loopAtEnd\") ? this.settings.loopAtEnd : null;\n        loop = $d8642219fb19b896$export$a4f4bb6b1453fff5(this.settings, \"loop\") ? this.settings.loop : loop;\n        return loop;\n    }\n    /**\n     * Close Lightbox\n     * closes the lightbox and removes the slides\n     * and some classes\n     */ close() {\n        if (!this.lightboxOpen) {\n            if (this.events) {\n                for(let key in this.events)if (this.events.hasOwnProperty(key)) this.events[key].destroy();\n                this.events = null;\n            }\n            return false;\n        }\n        if (this.closing) return false;\n        this.closing = true;\n        this.slidePlayerPause(this.activeSlide);\n        if (this.fullElementsList) this.elements = this.fullElementsList;\n        if (this.bodyHiddenChildElms.length) $d8642219fb19b896$export$79b2f7037acddd43(this.bodyHiddenChildElms, (el)=>{\n            el.removeAttribute(\"aria-hidden\");\n        });\n        $d8642219fb19b896$export$d2cf6cd1dc7067d3(this.modal, \"glightbox-closing\");\n        $d8642219fb19b896$export$5ed9d0a3cf9b0f86(this.overlay, this.settings.openEffect == \"none\" ? \"none\" : this.settings.cssEfects.fade.out);\n        $d8642219fb19b896$export$5ed9d0a3cf9b0f86(this.activeSlide, this.settings.cssEfects[this.settings.closeEffect].out, ()=>{\n            this.activeSlide = null;\n            this.prevActiveSlideIndex = null;\n            this.prevActiveSlide = null;\n            this.built = false;\n            if (this.events) {\n                for(let key in this.events)if (this.events.hasOwnProperty(key)) this.events[key].destroy();\n                this.events = null;\n            }\n            const body = document.body;\n            $d8642219fb19b896$export$c2255604a80b4506($81a53f2a460b34f6$var$html, \"glightbox-open\");\n            $d8642219fb19b896$export$c2255604a80b4506(body, \"glightbox-open touching gdesc-open glightbox-touch glightbox-mobile gscrollbar-fixer\");\n            this.modal.parentNode.removeChild(this.modal);\n            this.trigger(\"close\");\n            // settings.onClose is deprecated and will be removed in a future update\n            if ($d8642219fb19b896$export$f6e2535fb5126e54(this.settings.onClose)) this.settings.onClose();\n            const styles = document.querySelector(\".gcss-styles\");\n            if (styles) styles.parentNode.removeChild(styles);\n            this.lightboxOpen = false;\n            this.closing = null;\n        });\n    }\n    /**\n     * Destroy lightbox\n     * and all events\n     */ destroy() {\n        this.close();\n        this.clearAllEvents();\n        if (this.baseEvents) this.baseEvents.destroy();\n    }\n    /**\n     * Set event\n     */ on(evt, callback, once = false) {\n        if (!evt || !$d8642219fb19b896$export$f6e2535fb5126e54(callback)) throw new TypeError(\"Event name and callback must be defined\");\n        this.apiEvents.push({\n            evt: evt,\n            once: once,\n            callback: callback\n        });\n    }\n    /**\n     * Set event\n     */ once(evt, callback) {\n        this.on(evt, callback, true);\n    }\n    /**\n     * Triggers an specific event\n     * with data\n     *\n     * @param string eventName\n     */ trigger(eventName, data = null) {\n        const onceTriggered = [];\n        $d8642219fb19b896$export$79b2f7037acddd43(this.apiEvents, (event, i)=>{\n            const { evt: evt, once: once, callback: callback } = event;\n            if (evt == eventName) {\n                callback(data);\n                if (once) onceTriggered.push(i);\n            }\n        });\n        if (onceTriggered.length) $d8642219fb19b896$export$79b2f7037acddd43(onceTriggered, (i)=>this.apiEvents.splice(i, 1));\n    }\n    /**\n     * Removes all events\n     * set using the API\n     */ clearAllEvents() {\n        this.apiEvents.splice(0, this.apiEvents.length);\n    }\n    /**\n     * Get Version\n     */ version() {\n        return $81a53f2a460b34f6$var$version;\n    }\n}\nfunction $81a53f2a460b34f6$export$2e2bcd8739ae039(options = {}) {\n    const instance = new $81a53f2a460b34f6$var$GlightboxInit(options);\n    instance.init();\n    return instance;\n}\n\n\n//# sourceMappingURL=index.8e09efe2.js.map\n","/**\n * GLightbox\n * Awesome pure javascript lightbox\n * made by https://www.biati.digital\n * Github: https://github.com/biati-digital/glightbox\n */\n\nimport keyboardNavigation from './core/keyboard-navigation.js';\nimport Slide from './core/slide.js';\nimport touchNavigation from './core/touch-navigation.js';\nimport * as _ from './utils/helpers.js';\n\nconst version = '3.3.0';\nconst isMobile = _.isMobile();\nconst isTouch = _.isTouch();\nconst html = document.getElementsByTagName('html')[0];\n\nconst defaults = {\n    selector: '.glightbox',\n    elements: null,\n    skin: 'clean',\n    theme: 'clean',\n    closeButton: true,\n    startAt: null,\n    autoplayVideos: true,\n    autofocusVideos: true,\n    descPosition: 'bottom',\n    width: '900px',\n    height: '506px',\n    videosWidth: '960px',\n    beforeSlideChange: null,\n    afterSlideChange: null,\n    beforeSlideLoad: null,\n    afterSlideLoad: null,\n    slideInserted: null,\n    slideRemoved: null,\n    slideExtraAttributes: null,\n    onOpen: null,\n    onClose: null,\n    loop: false,\n    zoomable: true,\n    draggable: true,\n    dragAutoSnap: false,\n    dragToleranceX: 40,\n    dragToleranceY: 65,\n    preload: true,\n    oneSlidePerOpen: false,\n    touchNavigation: true,\n    touchFollowAxis: true,\n    keyboardNavigation: true,\n    closeOnOutsideClick: true,\n    plugins: false,\n    plyr: {\n        css: 'https://cdn.plyr.io/3.6.12/plyr.css',\n        js: 'https://cdn.plyr.io/3.6.12/plyr.js',\n        config: {\n            ratio: '16:9', // or '4:3'\n            fullscreen: { enabled: true, iosNative: true },\n            youtube: {\n                noCookie: true,\n                rel: 0,\n                showinfo: 0,\n                iv_load_policy: 3 // eslint-disable-line camelcase\n            },\n            vimeo: {\n                byline: false,\n                portrait: false,\n                title: false,\n                transparent: false\n            }\n        }\n    },\n    openEffect: 'zoom', // fade, zoom, none\n    closeEffect: 'zoom', // fade, zoom, none\n    slideEffect: 'slide', // fade, slide, zoom, none\n    moreText: 'See more',\n    moreLength: 60,\n    cssEfects: {\n        fade: { in: 'fadeIn', out: 'fadeOut' },\n        zoom: { in: 'zoomIn', out: 'zoomOut' },\n        slide: { in: 'slideInRight', out: 'slideOutLeft' },\n        slideBack: { in: 'slideInLeft', out: 'slideOutRight' },\n        none: { in: 'none', out: 'none' }\n    },\n    svg: {\n        close: '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 512 512\" xml:space=\"preserve\"><g><g><path d=\"M505.943,6.058c-8.077-8.077-21.172-8.077-29.249,0L6.058,476.693c-8.077,8.077-8.077,21.172,0,29.249C10.096,509.982,15.39,512,20.683,512c5.293,0,10.586-2.019,14.625-6.059L505.943,35.306C514.019,27.23,514.019,14.135,505.943,6.058z\"/></g></g><g><g><path d=\"M505.942,476.694L35.306,6.059c-8.076-8.077-21.172-8.077-29.248,0c-8.077,8.076-8.077,21.171,0,29.248l470.636,470.636c4.038,4.039,9.332,6.058,14.625,6.058c5.293,0,10.587-2.019,14.624-6.057C514.018,497.866,514.018,484.771,505.942,476.694z\"/></g></g></svg>',\n        next: '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 477.175 477.175\" xml:space=\"preserve\"> <g><path d=\"M360.731,229.075l-225.1-225.1c-5.3-5.3-13.8-5.3-19.1,0s-5.3,13.8,0,19.1l215.5,215.5l-215.5,215.5c-5.3,5.3-5.3,13.8,0,19.1c2.6,2.6,6.1,4,9.5,4c3.4,0,6.9-1.3,9.5-4l225.1-225.1C365.931,242.875,365.931,234.275,360.731,229.075z\"/></g></svg>',\n        prev: '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 477.175 477.175\" xml:space=\"preserve\"><g><path d=\"M145.188,238.575l215.5-215.5c5.3-5.3,5.3-13.8,0-19.1s-13.8-5.3-19.1,0l-225.1,225.1c-5.3,5.3-5.3,13.8,0,19.1l225.1,225c2.6,2.6,6.1,4,9.5,4s6.9-1.3,9.5-4c5.3-5.3,5.3-13.8,0-19.1L145.188,238.575z\"/></g></svg>'\n    }\n};\n\n// You can pass your own slide structure\n// just make sure that add the same classes so they are populated\n// title class = gslide-title\n// desc class = gslide-desc\n// prev arrow class = gnext\n// next arrow id = gprev\n// close id = gclose\ndefaults.slideHTML = `<div class=\"gslide\">\n    <div class=\"gslide-inner-content\">\n        <div class=\"ginner-container\">\n            <div class=\"gslide-media\">\n            </div>\n            <div class=\"gslide-description\">\n                <div class=\"gdesc-inner\">\n                    <h4 class=\"gslide-title\"></h4>\n                    <div class=\"gslide-desc\"></div>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>`;\n\ndefaults.lightboxHTML = `<div id=\"glightbox-body\" class=\"glightbox-container\" tabindex=\"-1\" role=\"dialog\" aria-hidden=\"false\">\n    <div class=\"gloader visible\"></div>\n    <div class=\"goverlay\"></div>\n    <div class=\"gcontainer\">\n    <div id=\"glightbox-slider\" class=\"gslider\"></div>\n    <button class=\"gclose gbtn\" aria-label=\"Close\" data-taborder=\"3\">{closeSVG}</button>\n    <button class=\"gprev gbtn\" aria-label=\"Previous\" data-taborder=\"2\">{prevSVG}</button>\n    <button class=\"gnext gbtn\" aria-label=\"Next\" data-taborder=\"1\">{nextSVG}</button>\n</div>\n</div>`;\n\n/**\n * GLightbox Class\n * Class and public methods\n */\nclass GlightboxInit {\n    constructor(options = {}) {\n        this.customOptions = options;\n        this.settings = _.extend(defaults, options);\n        this.effectsClasses = this.getAnimationClasses();\n        this.videoPlayers = {};\n        this.apiEvents = [];\n        this.fullElementsList = false;\n    }\n\n    init() {\n        const selector = this.getSelector();\n\n        if (selector) {\n            this.baseEvents = _.addEvent('click', {\n                onElement: selector,\n                withCallback: (e, target) => {\n                    e.preventDefault();\n                    this.open(target);\n                }\n            });\n        }\n\n        this.elements = this.getElements();\n    }\n\n    open(element = null, startAt = null) {\n        if (this.elements.length === 0) {\n            return false;\n        }\n\n        this.activeSlide = null;\n        this.prevActiveSlideIndex = null;\n        this.prevActiveSlide = null;\n        let index = _.isNumber(startAt) ? startAt : this.settings.startAt;\n\n        if (_.isNode(element)) {\n            const gallery = element.getAttribute('data-gallery');\n            if (gallery) {\n                this.fullElementsList = this.elements;\n                this.elements = this.getGalleryElements(this.elements, gallery);\n            }\n            if (_.isNil(index)) {\n                // get the index of the element\n                index = this.getElementIndex(element);\n                if (index < 0) {\n                    index = 0;\n                }\n            }\n        }\n\n        if (!_.isNumber(index)) {\n            index = 0;\n        }\n\n        this.build();\n\n        _.animateElement(this.overlay, this.settings.openEffect === 'none' ? 'none' : this.settings.cssEfects.fade.in);\n\n        const body = document.body;\n\n        const scrollBar = window.innerWidth - document.documentElement.clientWidth;\n        if (scrollBar > 0) {\n            var styleSheet = document.createElement('style');\n            styleSheet.type = 'text/css';\n            styleSheet.className = 'gcss-styles';\n            styleSheet.innerText = `.gscrollbar-fixer {margin-right: ${scrollBar}px}`;\n            document.head.appendChild(styleSheet);\n            _.addClass(body, 'gscrollbar-fixer');\n        }\n\n        _.addClass(body, 'glightbox-open');\n        _.addClass(html, 'glightbox-open');\n        if (isMobile) {\n            _.addClass(document.body, 'glightbox-mobile');\n            this.settings.slideEffect = 'slide';\n        }\n\n        this.showSlide(index, true);\n\n        if (this.elements.length === 1) {\n            _.addClass(this.prevButton, 'glightbox-button-hidden');\n            _.addClass(this.nextButton, 'glightbox-button-hidden');\n        } else {\n            _.removeClass(this.prevButton, 'glightbox-button-hidden');\n            _.removeClass(this.nextButton, 'glightbox-button-hidden');\n        }\n        this.lightboxOpen = true;\n\n        this.trigger('open');\n\n        // settings.onOpen is deprecated and will be removed in a future update\n        if (_.isFunction(this.settings.onOpen)) {\n            this.settings.onOpen();\n        }\n        if (isTouch && this.settings.touchNavigation) {\n            touchNavigation(this);\n        }\n        if (this.settings.keyboardNavigation) {\n            keyboardNavigation(this);\n        }\n    }\n\n    /**\n     * Open at specific index\n     * @param {int} index\n     */\n    openAt(index = 0) {\n        this.open(null, index);\n    }\n\n    /**\n     * Set Slide\n     */\n    showSlide(index = 0, first = false) {\n        _.show(this.loader);\n        this.index = parseInt(index);\n\n        let current = this.slidesContainer.querySelector('.current');\n        if (current) {\n            _.removeClass(current, 'current');\n        }\n\n        // hide prev slide\n        this.slideAnimateOut();\n\n        let slideNode = this.slidesContainer.querySelectorAll('.gslide')[index];\n\n        // Check if slide's content is alreay loaded\n        if (_.hasClass(slideNode, 'loaded')) {\n            this.slideAnimateIn(slideNode, first);\n            _.hide(this.loader);\n        } else {\n            // If not loaded add the slide content\n            _.show(this.loader);\n\n            const slide = this.elements[index];\n            const slideData = {\n                index: this.index,\n                slide: slideNode, //this will be removed in the future\n                slideNode: slideNode,\n                slideConfig: slide.slideConfig,\n                slideIndex: this.index,\n                trigger: slide.node,\n                player: null\n            };\n\n            this.trigger('slide_before_load', slideData);\n\n            slide.instance.setContent(slideNode, () => {\n                _.hide(this.loader);\n                this.resize();\n                this.slideAnimateIn(slideNode, first);\n                this.trigger('slide_after_load', slideData);\n            });\n        }\n\n        this.slideDescription = slideNode.querySelector('.gslide-description');\n        this.slideDescriptionContained = this.slideDescription && _.hasClass(this.slideDescription.parentNode, 'gslide-media');\n\n        // Preload subsequent slides\n        if (this.settings.preload) {\n            this.preloadSlide(index + 1);\n            this.preloadSlide(index - 1);\n        }\n\n        // Handle navigation arrows\n        this.updateNavigationClasses();\n\n        this.activeSlide = slideNode;\n    }\n\n    /**\n     * Preload slides\n     * @param  {Int}  index slide index\n     * @return {null}\n     */\n    preloadSlide(index) {\n        // Verify slide index, it can not be lower than 0\n        // and it can not be greater than the total elements\n        if (index < 0 || index > this.elements.length - 1) {\n            return false;\n        }\n\n        if (_.isNil(this.elements[index])) {\n            return false;\n        }\n\n        let slideNode = this.slidesContainer.querySelectorAll('.gslide')[index];\n        if (_.hasClass(slideNode, 'loaded')) {\n            return false;\n        }\n\n        const slide = this.elements[index];\n        const type = slide.type;\n        const slideData = {\n            index: index,\n            slide: slideNode, //this will be removed in the future\n            slideNode: slideNode,\n            slideConfig: slide.slideConfig,\n            slideIndex: index,\n            trigger: slide.node,\n            player: null\n        };\n\n        this.trigger('slide_before_load', slideData);\n\n        if (type === 'video' || type === 'external') {\n            setTimeout(() => {\n                slide.instance.setContent(slideNode, () => {\n                    this.trigger('slide_after_load', slideData);\n                });\n            }, 200);\n        } else {\n            slide.instance.setContent(slideNode, () => {\n                this.trigger('slide_after_load', slideData);\n            });\n        }\n    }\n\n    /**\n     * Load previous slide\n     * calls goToslide\n     */\n    prevSlide() {\n        this.goToSlide(this.index - 1);\n    }\n\n    /**\n     * Load next slide\n     * calls goToslide\n     */\n    nextSlide() {\n        this.goToSlide(this.index + 1);\n    }\n\n    /**\n     * Go to sldei\n     * calls set slide\n     * @param {Int} - index\n     */\n    goToSlide(index = false) {\n        this.prevActiveSlide = this.activeSlide;\n        this.prevActiveSlideIndex = this.index;\n\n        if (!this.loop() && (index < 0 || index > this.elements.length - 1)) {\n            return false;\n        }\n        if (index < 0) {\n            index = this.elements.length - 1;\n        } else if (index >= this.elements.length) {\n            index = 0;\n        }\n        this.showSlide(index);\n    }\n\n    /**\n     * Insert slide\n     *\n     * @param { object } data\n     * @param { numeric } position\n     */\n    insertSlide(config = {}, index = -1) {\n        // Append at the end\n        if (index < 0) {\n            index = this.elements.length;\n        }\n\n        const slide = new Slide(config, this, index);\n        const data = slide.getConfig();\n        const slideInfo = _.extend({}, data);\n        const newSlide = slide.create();\n        const totalSlides = this.elements.length - 1;\n\n        slideInfo.index = index;\n        slideInfo.node = false;\n        slideInfo.instance = slide;\n        slideInfo.slideConfig = data;\n        this.elements.splice(index, 0, slideInfo);\n\n        let addedSlideNode = null;\n        let addedSlidePlayer = null;\n\n        if (this.slidesContainer) {\n            // Append at the end\n            if (index > totalSlides) {\n                this.slidesContainer.appendChild(newSlide);\n            } else {\n                // A current slide must exist in the position specified\n                // we need tp get that slide and insder the new slide before\n                let existingSlide = this.slidesContainer.querySelectorAll('.gslide')[index];\n                this.slidesContainer.insertBefore(newSlide, existingSlide);\n            }\n\n            if ((this.settings.preload && this.index == 0 && index == 0) || this.index - 1 == index || this.index + 1 == index) {\n                this.preloadSlide(index);\n            }\n\n            if (this.index === 0 && index === 0) {\n                this.index = 1;\n            }\n\n            this.updateNavigationClasses();\n\n            addedSlideNode = this.slidesContainer.querySelectorAll('.gslide')[index];\n            addedSlidePlayer = this.getSlidePlayerInstance(index);\n            slideInfo.slideNode = addedSlideNode;\n        }\n\n        this.trigger('slide_inserted', {\n            index: index,\n            slide: addedSlideNode,\n            slideNode: addedSlideNode,\n            slideConfig: data,\n            slideIndex: index,\n            trigger: null,\n            player: addedSlidePlayer\n        });\n\n        // Deprecated and will be removed in a future update\n        if (_.isFunction(this.settings.slideInserted)) {\n            this.settings.slideInserted({\n                index: index,\n                slide: addedSlideNode,\n                player: addedSlidePlayer\n            });\n        }\n    }\n\n    /**\n     * Remove slide\n     *\n     * @param { numeric } position\n     */\n    removeSlide(index = -1) {\n        if (index < 0 || index > this.elements.length - 1) {\n            return false;\n        }\n\n        const slide = this.slidesContainer && this.slidesContainer.querySelectorAll('.gslide')[index];\n\n        if (slide) {\n            if (this.getActiveSlideIndex() == index) {\n                if (index == this.elements.length - 1) {\n                    this.prevSlide();\n                } else {\n                    this.nextSlide();\n                }\n            }\n            slide.parentNode.removeChild(slide);\n        }\n        this.elements.splice(index, 1);\n\n        this.trigger('slide_removed', index);\n\n        // Deprecated and will be removed in a future update\n        if (_.isFunction(this.settings.slideRemoved)) {\n            this.settings.slideRemoved(index);\n        }\n    }\n\n    /**\n     * Slide In\n     * @return {null}\n     */\n    slideAnimateIn(slide, first) {\n        let slideMedia = slide.querySelector('.gslide-media');\n        let slideDesc = slide.querySelector('.gslide-description');\n        let prevData = {\n            index: this.prevActiveSlideIndex,\n            slide: this.prevActiveSlide, //this will be removed in the future\n            slideNode: this.prevActiveSlide,\n            slideIndex: this.prevActiveSlide,\n            slideConfig: _.isNil(this.prevActiveSlideIndex) ? null : this.elements[this.prevActiveSlideIndex].slideConfig,\n            trigger: _.isNil(this.prevActiveSlideIndex) ? null : this.elements[this.prevActiveSlideIndex].node,\n            player: this.getSlidePlayerInstance(this.prevActiveSlideIndex)\n        };\n\n        let nextData = {\n            index: this.index,\n            slide: this.activeSlide, //this will be removed in the future\n            slideNode: this.activeSlide,\n            slideConfig: this.elements[this.index].slideConfig,\n            slideIndex: this.index,\n            trigger: this.elements[this.index].node,\n            player: this.getSlidePlayerInstance(this.index)\n        };\n        if (slideMedia.offsetWidth > 0 && slideDesc) {\n            _.hide(slideDesc);\n            slideDesc.style.display = '';\n        }\n\n        _.removeClass(slide, this.effectsClasses);\n\n        if (first) {\n            _.animateElement(slide, this.settings.cssEfects[this.settings.openEffect].in, () => {\n                if (this.settings.autoplayVideos) {\n                    this.slidePlayerPlay(slide);\n                }\n\n                this.trigger('slide_changed', {\n                    prev: prevData,\n                    current: nextData\n                });\n\n                // settings.afterSlideChange is deprecated and will be removed in a future update\n                if (_.isFunction(this.settings.afterSlideChange)) {\n                    this.settings.afterSlideChange.apply(this, [prevData, nextData]);\n                }\n            });\n        } else {\n            let effectName = this.settings.slideEffect;\n            let animIn = effectName !== 'none' ? this.settings.cssEfects[effectName].in : effectName;\n            if (this.prevActiveSlideIndex > this.index) {\n                if (this.settings.slideEffect == 'slide') {\n                    animIn = this.settings.cssEfects.slideBack.in;\n                }\n            }\n            _.animateElement(slide, animIn, () => {\n                if (this.settings.autoplayVideos) {\n                    this.slidePlayerPlay(slide);\n                }\n\n                this.trigger('slide_changed', {\n                    prev: prevData,\n                    current: nextData\n                });\n\n                // settings.afterSlideChange is deprecated and will be removed in a future update\n                if (_.isFunction(this.settings.afterSlideChange)) {\n                    this.settings.afterSlideChange.apply(this, [prevData, nextData]);\n                }\n            });\n        }\n\n        setTimeout(() => {\n            this.resize(slide);\n        }, 100);\n        _.addClass(slide, 'current');\n    }\n\n    /**\n     * Slide out\n     */\n    slideAnimateOut() {\n        if (!this.prevActiveSlide) {\n            return false;\n        }\n\n        let prevSlide = this.prevActiveSlide;\n        _.removeClass(prevSlide, this.effectsClasses);\n        _.addClass(prevSlide, 'prev');\n\n        let animation = this.settings.slideEffect;\n        let animOut = animation !== 'none' ? this.settings.cssEfects[animation].out : animation;\n\n        this.slidePlayerPause(prevSlide);\n\n        this.trigger('slide_before_change', {\n            prev: {\n                index: this.prevActiveSlideIndex, //this will be removed in the future\n                slide: this.prevActiveSlide, //this will be removed in the future\n                slideNode: this.prevActiveSlide,\n                slideIndex: this.prevActiveSlideIndex,\n                slideConfig: _.isNil(this.prevActiveSlideIndex) ? null : this.elements[this.prevActiveSlideIndex].slideConfig,\n                trigger: _.isNil(this.prevActiveSlideIndex) ? null : this.elements[this.prevActiveSlideIndex].node,\n                player: this.getSlidePlayerInstance(this.prevActiveSlideIndex)\n            },\n            current: {\n                index: this.index, //this will be removed in the future\n                slide: this.activeSlide, //this will be removed in the future\n                slideNode: this.activeSlide,\n                slideIndex: this.index,\n                slideConfig: this.elements[this.index].slideConfig,\n                trigger: this.elements[this.index].node,\n                player: this.getSlidePlayerInstance(this.index)\n            }\n        });\n\n        // settings.beforeSlideChange is deprecated and will be removed in a future update\n        if (_.isFunction(this.settings.beforeSlideChange)) {\n            this.settings.beforeSlideChange.apply(this, [\n                {\n                    index: this.prevActiveSlideIndex,\n                    slide: this.prevActiveSlide,\n                    player: this.getSlidePlayerInstance(this.prevActiveSlideIndex)\n                },\n                {\n                    index: this.index,\n                    slide: this.activeSlide,\n                    player: this.getSlidePlayerInstance(this.index)\n                }\n            ]);\n        }\n        if (this.prevActiveSlideIndex > this.index && this.settings.slideEffect == 'slide') {\n            // going back\n            animOut = this.settings.cssEfects.slideBack.out;\n        }\n        _.animateElement(prevSlide, animOut, () => {\n            let container = prevSlide.querySelector('.ginner-container');\n            let media = prevSlide.querySelector('.gslide-media');\n            let desc = prevSlide.querySelector('.gslide-description');\n\n            container.style.transform = '';\n            media.style.transform = '';\n            _.removeClass(media, 'greset');\n            media.style.opacity = '';\n            if (desc) {\n                desc.style.opacity = '';\n            }\n            _.removeClass(prevSlide, 'prev');\n        });\n    }\n\n    /**\n     * Get all defined players\n     */\n    getAllPlayers() {\n        return this.videoPlayers;\n    }\n\n    /**\n     * Get player at index\n     *\n     * @param index\n     * @return bool|object\n     */\n    getSlidePlayerInstance(index) {\n        const id = 'gvideo' + index;\n        const videoPlayers = this.getAllPlayers();\n\n        if (_.has(videoPlayers, id) && videoPlayers[id]) {\n            return videoPlayers[id];\n        }\n\n        return false;\n    }\n\n    /**\n     * Stop video at specified\n     * node or index\n     *\n     * @param slide node or index\n     * @return void\n     */\n    stopSlideVideo(slide) {\n        if (_.isNode(slide)) {\n            let node = slide.querySelector('.gvideo-wrapper');\n            if (node) {\n                slide = node.getAttribute('data-index');\n            }\n        }\n        console.log('stopSlideVideo is deprecated, use slidePlayerPause');\n        const player = this.getSlidePlayerInstance(slide);\n        if (player && player.playing) {\n            player.pause();\n        }\n    }\n\n    /**\n     * Stop player at specified index\n     *\n     * @param slide node or index\n     * @return void\n     */\n    slidePlayerPause(slide) {\n        if (_.isNode(slide)) {\n            let node = slide.querySelector('.gvideo-wrapper');\n            if (node) {\n                slide = node.getAttribute('data-index');\n            }\n        }\n        const player = this.getSlidePlayerInstance(slide);\n        if (player && player.playing) {\n            player.pause();\n        }\n    }\n\n    /**\n     * Play video at specified\n     * node or index\n     *\n     * @param slide node or index\n     * @return void\n     */\n    playSlideVideo(slide) {\n        if (_.isNode(slide)) {\n            let node = slide.querySelector('.gvideo-wrapper');\n            if (node) {\n                slide = node.getAttribute('data-index');\n            }\n        }\n        console.log('playSlideVideo is deprecated, use slidePlayerPlay');\n        const player = this.getSlidePlayerInstance(slide);\n        if (player && !player.playing) {\n            player.play();\n        }\n    }\n\n    /**\n     * Play media player at specified\n     * node or index\n     *\n     * @param slide node or index\n     * @return void\n     */\n    slidePlayerPlay(slide) {\n        // Do not autoplay on mobile\n        // plyr does not handle well the errors\n        // and the player becomes unplayable\n        if (isMobile && !this.settings.plyr.config?.muted) {\n            return;\n        }\n\n        if (_.isNode(slide)) {\n            let node = slide.querySelector('.gvideo-wrapper');\n            if (node) {\n                slide = node.getAttribute('data-index');\n            }\n        }\n\n        const player = this.getSlidePlayerInstance(slide);\n\n        if (player && !player.playing) {\n            player.play();\n            if (this.settings.autofocusVideos) {\n                player.elements.container.focus();\n            }\n        }\n    }\n\n    /**\n     * Set the entire elements\n     * in the gallery, it replaces all\n     * the existing elements\n     * with the specified list\n     *\n     * @param {array}  elements\n     */\n    setElements(elements) {\n        this.settings.elements = false;\n\n        const newElements = [];\n\n        if (elements && elements.length) {\n            _.each(elements, (el, i) => {\n                const slide = new Slide(el, this, i);\n                const data = slide.getConfig();\n                const slideInfo = _.extend({}, data);\n\n                slideInfo.slideConfig = data;\n                slideInfo.instance = slide;\n                slideInfo.index = i;\n                newElements.push(slideInfo);\n            });\n        }\n\n        this.elements = newElements;\n\n        if (this.lightboxOpen) {\n            this.slidesContainer.innerHTML = '';\n\n            if (this.elements.length) {\n                _.each(this.elements, () => {\n                    let slide = _.createHTML(this.settings.slideHTML);\n                    this.slidesContainer.appendChild(slide);\n                });\n                this.showSlide(0, true);\n            }\n        }\n    }\n\n    /**\n     * Return the index\n     * of the specified node,\n     * this node is for example an image, link, etc.\n     * that when clicked it opens the lightbox\n     * its position in the elements array can change\n     * when using insertSlide or removeSlide so we\n     * need to find it in the elements list\n     *\n     * @param {node} node\n     * @return bool|int\n     */\n    getElementIndex(node) {\n        let index = false;\n        _.each(this.elements, (el, i) => {\n            if (_.has(el, 'node') && el.node == node) {\n                index = i;\n                return true; // exit loop\n            }\n        });\n\n        return index;\n    }\n\n    /**\n     * Get elements\n     * returns an array containing all\n     * the elements that must be displayed in the\n     * lightbox\n     *\n     * @return { array }\n     */\n    getElements() {\n        let list = [];\n        this.elements = this.elements ? this.elements : [];\n\n        if (!_.isNil(this.settings.elements) && _.isArray(this.settings.elements) && this.settings.elements.length) {\n            _.each(this.settings.elements, (el, i) => {\n                const slide = new Slide(el, this, i);\n                const elData = slide.getConfig();\n                const slideInfo = _.extend({}, elData);\n\n                slideInfo.node = false;\n                slideInfo.index = i;\n                slideInfo.instance = slide;\n                slideInfo.slideConfig = elData;\n                list.push(slideInfo);\n            });\n        }\n\n        let nodes = false;\n        let selector = this.getSelector();\n\n        if (selector) {\n            nodes = document.querySelectorAll(this.getSelector());\n        }\n\n        if (!nodes) {\n            return list;\n        }\n\n        _.each(nodes, (el, i) => {\n            const slide = new Slide(el, this, i);\n            const elData = slide.getConfig();\n            const slideInfo = _.extend({}, elData);\n\n            slideInfo.node = el;\n            slideInfo.index = i;\n            slideInfo.instance = slide;\n            slideInfo.slideConfig = elData;\n            slideInfo.gallery = el.getAttribute('data-gallery');\n            list.push(slideInfo);\n        });\n\n        return list;\n    }\n\n    /**\n     * Return only the elements\n     * from a specific gallery\n     *\n     * @return array\n     */\n    getGalleryElements(list, gallery) {\n        return list.filter((el) => {\n            return el.gallery == gallery;\n        });\n    }\n\n    /**\n     * Get selector\n     */\n    getSelector() {\n        if (this.settings.elements) {\n            return false;\n        }\n        if (this.settings.selector && this.settings.selector.substring(0, 5) == 'data-') {\n            return `*[${this.settings.selector}]`;\n        }\n        return this.settings.selector;\n    }\n\n    /**\n     * Get the active slide\n     */\n    getActiveSlide() {\n        return this.slidesContainer.querySelectorAll('.gslide')[this.index];\n    }\n\n    /**\n     * Get the active index\n     */\n    getActiveSlideIndex() {\n        return this.index;\n    }\n\n    /**\n     * Get the defined\n     * effects as string\n     */\n    getAnimationClasses() {\n        let effects = [];\n        for (let key in this.settings.cssEfects) {\n            if (this.settings.cssEfects.hasOwnProperty(key)) {\n                let effect = this.settings.cssEfects[key];\n                effects.push(`g${effect.in}`);\n                effects.push(`g${effect.out}`);\n            }\n        }\n        return effects.join(' ');\n    }\n\n    /**\n     * Build the structure\n     * @return {null}\n     */\n    build() {\n        if (this.built) {\n            return false;\n        }\n\n        // TODO: :scope is not supported on IE or first Edge. so we'll\n        // update this when IE support is removed to use newer code\n        //const children = document.body.querySelectorAll(':scope > *');\n        const children = document.body.childNodes;\n        const bodyChildElms = [];\n        _.each(children, (el) => {\n            if (el.parentNode == document.body && el.nodeName.charAt(0) !== '#' && el.hasAttribute && !el.hasAttribute('aria-hidden')) {\n                bodyChildElms.push(el);\n                el.setAttribute('aria-hidden', 'true');\n            }\n        });\n\n        const nextSVG = _.has(this.settings.svg, 'next') ? this.settings.svg.next : '';\n        const prevSVG = _.has(this.settings.svg, 'prev') ? this.settings.svg.prev : '';\n        const closeSVG = _.has(this.settings.svg, 'close') ? this.settings.svg.close : '';\n\n        let lightboxHTML = this.settings.lightboxHTML;\n        lightboxHTML = lightboxHTML.replace(/{nextSVG}/g, nextSVG);\n        lightboxHTML = lightboxHTML.replace(/{prevSVG}/g, prevSVG);\n        lightboxHTML = lightboxHTML.replace(/{closeSVG}/g, closeSVG);\n\n        lightboxHTML = _.createHTML(lightboxHTML);\n        document.body.appendChild(lightboxHTML);\n\n        const modal = document.getElementById('glightbox-body');\n        this.modal = modal;\n        let closeButton = modal.querySelector('.gclose');\n        this.prevButton = modal.querySelector('.gprev');\n        this.nextButton = modal.querySelector('.gnext');\n        this.overlay = modal.querySelector('.goverlay');\n        this.loader = modal.querySelector('.gloader');\n        this.slidesContainer = document.getElementById('glightbox-slider');\n        this.bodyHiddenChildElms = bodyChildElms;\n        this.events = {};\n\n        _.addClass(this.modal, 'glightbox-' + this.settings.skin);\n\n        if (this.settings.closeButton && closeButton) {\n            this.events['close'] = _.addEvent('click', {\n                onElement: closeButton,\n                withCallback: (e, target) => {\n                    e.preventDefault();\n                    this.close();\n                }\n            });\n        }\n        if (closeButton && !this.settings.closeButton) {\n            closeButton.parentNode.removeChild(closeButton);\n        }\n\n        if (this.nextButton) {\n            this.events['next'] = _.addEvent('click', {\n                onElement: this.nextButton,\n                withCallback: (e, target) => {\n                    e.preventDefault();\n                    this.nextSlide();\n                }\n            });\n        }\n\n        if (this.prevButton) {\n            this.events['prev'] = _.addEvent('click', {\n                onElement: this.prevButton,\n                withCallback: (e, target) => {\n                    e.preventDefault();\n                    this.prevSlide();\n                }\n            });\n        }\n        if (this.settings.closeOnOutsideClick) {\n            this.events['outClose'] = _.addEvent('click', {\n                onElement: modal,\n                withCallback: (e, target) => {\n                    if (!this.preventOutsideClick && !_.hasClass(document.body, 'glightbox-mobile') && !_.closest(e.target, '.ginner-container')) {\n                        if (!_.closest(e.target, '.gbtn') && !_.hasClass(e.target, 'gnext') && !_.hasClass(e.target, 'gprev')) {\n                            this.close();\n                        }\n                    }\n                }\n            });\n        }\n\n        _.each(this.elements, (slide, i) => {\n            this.slidesContainer.appendChild(slide.instance.create());\n            slide.slideNode = this.slidesContainer.querySelectorAll('.gslide')[i];\n        });\n        if (isTouch) {\n            _.addClass(document.body, 'glightbox-touch');\n        }\n\n        this.events['resize'] = _.addEvent('resize', {\n            onElement: window,\n            withCallback: () => {\n                this.resize();\n            }\n        });\n\n        this.built = true;\n    }\n\n    /**\n     * Handle resize\n     * Create only to handle\n     * when the height of the screen\n     * is lower than the slide content\n     * this helps to resize videos vertically\n     * and images with description\n     */\n    resize(slide = null) {\n        slide = !slide ? this.activeSlide : slide;\n\n        if (!slide || _.hasClass(slide, 'zoomed')) {\n            return;\n        }\n\n        const winSize = _.windowSize();\n        const video = slide.querySelector('.gvideo-wrapper');\n        const image = slide.querySelector('.gslide-image');\n        const description = this.slideDescription;\n\n        let winWidth = winSize.width;\n        let winHeight = winSize.height;\n\n        if (winWidth <= 768) {\n            _.addClass(document.body, 'glightbox-mobile');\n        } else {\n            _.removeClass(document.body, 'glightbox-mobile');\n        }\n\n        if (!video && !image) {\n            return;\n        }\n\n        let descriptionResize = false;\n        if (description && (_.hasClass(description, 'description-bottom') || _.hasClass(description, 'description-top')) && !_.hasClass(description, 'gabsolute')) {\n            descriptionResize = true;\n        }\n\n        if (image) {\n            if (winWidth <= 768) {\n                let imgNode = image.querySelector('img');\n                //imgNode.setAttribute('style', '');\n            } else if (descriptionResize) {\n                let descHeight = description.offsetHeight;\n                let imgNode = image.querySelector('img');\n\n                // if a slide height is set via data-height, we want to use that\n                // if not, we fall back to 100vh\n                const slideTriggerNode = this.elements[this.index].node;\n                const maxHeightValue = slideTriggerNode.getAttribute('data-height') ?? '100vh';\n\n                imgNode.setAttribute('style', `max-height: calc(${maxHeightValue} - ${descHeight}px)`);\n                description.setAttribute('style', `max-width: ${imgNode.offsetWidth}px;`);\n            }\n        }\n\n        if (video) {\n            let ratio = _.has(this.settings.plyr.config, 'ratio') ? this.settings.plyr.config.ratio : '';\n\n            if (!ratio) {\n                // If no ratio passed, calculate it using the video width and height\n                // generated by Plyr\n                const containerWidth = video.clientWidth;\n                const containerHeight = video.clientHeight;\n                const divisor = containerWidth / containerHeight;\n                ratio = `${containerWidth / divisor}:${containerHeight / divisor}`;\n            }\n\n            let videoRatio = ratio.split(':');\n            let videoWidth = this.settings.videosWidth;\n            let maxWidth = this.settings.videosWidth;\n\n            if (_.isNumber(videoWidth) || videoWidth.indexOf('px') !== -1) {\n                maxWidth = parseInt(videoWidth);\n            } else {\n                // If video size is vw, vh or % convert it to pixels,\n                // fallback to the current video size\n                if (videoWidth.indexOf('vw') !== -1) {\n                    maxWidth = (winWidth * parseInt(videoWidth)) / 100;\n                } else if (videoWidth.indexOf('vh') !== -1) {\n                    maxWidth = (winHeight * parseInt(videoWidth)) / 100;\n                } else if (videoWidth.indexOf('%') !== -1) {\n                    maxWidth = (winWidth * parseInt(videoWidth)) / 100;\n                } else {\n                    maxWidth = parseInt(video.clientWidth);\n                }\n            }\n\n            let maxHeight = maxWidth / (parseInt(videoRatio[0]) / parseInt(videoRatio[1]));\n            maxHeight = Math.floor(maxHeight);\n\n            if (descriptionResize) {\n                winHeight = winHeight - description.offsetHeight;\n            }\n\n            if (maxWidth > winWidth || maxHeight > winHeight || (winHeight < maxHeight && winWidth > maxWidth)) {\n                let vwidth = video.offsetWidth;\n                let vheight = video.offsetHeight;\n                let ratio = winHeight / vheight;\n                let vsize = { width: vwidth * ratio, height: vheight * ratio };\n                video.parentNode.setAttribute('style', `max-width: ${vsize.width}px`);\n\n                if (descriptionResize) {\n                    description.setAttribute('style', `max-width: ${vsize.width}px;`);\n                }\n            } else {\n                video.parentNode.style.maxWidth = `${videoWidth}`;\n                if (descriptionResize) {\n                    description.setAttribute('style', `max-width: ${videoWidth};`);\n                }\n            }\n        }\n    }\n\n    /**\n     * Reload Lightbox\n     * reload and apply events to nodes\n     */\n    reload() {\n        this.init();\n    }\n\n    /**\n     * Update navigation classes on slide change\n     */\n    updateNavigationClasses() {\n        const loop = this.loop();\n        // Handle navigation arrows\n        _.removeClass(this.nextButton, 'disabled');\n        _.removeClass(this.prevButton, 'disabled');\n\n        if (this.index == 0 && this.elements.length - 1 == 0) {\n            _.addClass(this.prevButton, 'disabled');\n            _.addClass(this.nextButton, 'disabled');\n        } else if (this.index === 0 && !loop) {\n            _.addClass(this.prevButton, 'disabled');\n        } else if (this.index === this.elements.length - 1 && !loop) {\n            _.addClass(this.nextButton, 'disabled');\n        }\n    }\n\n    /**\n     * Handle loop config\n     */\n    loop() {\n        let loop = _.has(this.settings, 'loopAtEnd') ? this.settings.loopAtEnd : null;\n        loop = _.has(this.settings, 'loop') ? this.settings.loop : loop;\n\n        return loop;\n    }\n\n    /**\n     * Close Lightbox\n     * closes the lightbox and removes the slides\n     * and some classes\n     */\n    close() {\n        if (!this.lightboxOpen) {\n            if (this.events) {\n                for (let key in this.events) {\n                    if (this.events.hasOwnProperty(key)) {\n                        this.events[key].destroy();\n                    }\n                }\n                this.events = null;\n            }\n            return false;\n        }\n\n        if (this.closing) {\n            return false;\n        }\n        this.closing = true;\n        this.slidePlayerPause(this.activeSlide);\n\n        if (this.fullElementsList) {\n            this.elements = this.fullElementsList;\n        }\n\n        if (this.bodyHiddenChildElms.length) {\n            _.each(this.bodyHiddenChildElms, (el) => {\n                el.removeAttribute('aria-hidden');\n            });\n        }\n\n        _.addClass(this.modal, 'glightbox-closing');\n        _.animateElement(this.overlay, this.settings.openEffect == 'none' ? 'none' : this.settings.cssEfects.fade.out);\n        _.animateElement(this.activeSlide, this.settings.cssEfects[this.settings.closeEffect].out, () => {\n            this.activeSlide = null;\n            this.prevActiveSlideIndex = null;\n            this.prevActiveSlide = null;\n            this.built = false;\n\n            if (this.events) {\n                for (let key in this.events) {\n                    if (this.events.hasOwnProperty(key)) {\n                        this.events[key].destroy();\n                    }\n                }\n                this.events = null;\n            }\n\n            const body = document.body;\n            _.removeClass(html, 'glightbox-open');\n            _.removeClass(body, 'glightbox-open touching gdesc-open glightbox-touch glightbox-mobile gscrollbar-fixer');\n            this.modal.parentNode.removeChild(this.modal);\n\n            this.trigger('close');\n\n            // settings.onClose is deprecated and will be removed in a future update\n            if (_.isFunction(this.settings.onClose)) {\n                this.settings.onClose();\n            }\n\n            const styles = document.querySelector('.gcss-styles');\n            if (styles) {\n                styles.parentNode.removeChild(styles);\n            }\n            this.lightboxOpen = false;\n            this.closing = null;\n        });\n    }\n\n    /**\n     * Destroy lightbox\n     * and all events\n     */\n    destroy() {\n        this.close();\n        this.clearAllEvents();\n\n        if (this.baseEvents) {\n            this.baseEvents.destroy();\n        }\n    }\n\n    /**\n     * Set event\n     */\n    on(evt, callback, once = false) {\n        if (!evt || !_.isFunction(callback)) {\n            throw new TypeError('Event name and callback must be defined');\n        }\n        this.apiEvents.push({ evt, once, callback });\n    }\n\n    /**\n     * Set event\n     */\n    once(evt, callback) {\n        this.on(evt, callback, true);\n    }\n\n    /**\n     * Triggers an specific event\n     * with data\n     *\n     * @param string eventName\n     */\n    trigger(eventName, data = null) {\n        const onceTriggered = [];\n        _.each(this.apiEvents, (event, i) => {\n            const { evt, once, callback } = event;\n            if (evt == eventName) {\n                callback(data);\n                if (once) {\n                    onceTriggered.push(i);\n                }\n            }\n        });\n        if (onceTriggered.length) {\n            _.each(onceTriggered, (i) => this.apiEvents.splice(i, 1));\n        }\n    }\n\n    /**\n     * Removes all events\n     * set using the API\n     */\n    clearAllEvents() {\n        this.apiEvents.splice(0, this.apiEvents.length);\n    }\n\n    /**\n     * Get Version\n     */\n    version() {\n        return version;\n    }\n}\n\nexport default function (options = {}) {\n    const instance = new GlightboxInit(options);\n    instance.init();\n\n    return instance;\n}\n","/**\n * Keyboard Navigation\n * Allow navigation using the keyboard\n *\n * @param {object} instance\n */\n\nimport { addEvent, addClass, removeClass, each } from '../utils/helpers.js';\n\nfunction getNextFocusElement(current = -1) {\n    const btns = document.querySelectorAll('.gbtn[data-taborder]:not(.disabled)');\n    if (!btns.length) {\n        return false;\n    }\n\n    if (btns.length == 1) {\n        return btns[0];\n    }\n\n    if (typeof current == 'string') {\n        current = parseInt(current);\n    }\n\n    const orders = [];\n    each(btns, (btn) => {\n        orders.push(btn.getAttribute('data-taborder'));\n    });\n    const highestOrder = Math.max.apply(Math, orders.map((order) => parseInt(order)));\n\n    let newIndex = current < 0 ? 1 : current + 1;\n    if (newIndex > highestOrder) {\n        newIndex = '1';\n    }\n\n    const nextOrders = orders.filter((el) => el >= parseInt(newIndex));\n    const nextFocus = nextOrders.sort()[0];\n\n    return document.querySelector(`.gbtn[data-taborder=\"${nextFocus}\"]`);\n}\n\nexport default function keyboardNavigation(instance) {\n    if (instance.events.hasOwnProperty('keyboard')) {\n        return false;\n    }\n\n    instance.events['keyboard'] = addEvent('keydown', {\n        onElement: window,\n        withCallback: (event, target) => {\n            event = event || window.event;\n            const key = event.keyCode;\n            if (key == 9) {\n                //prettier-ignore\n                const focusedButton = document.querySelector('.gbtn.focused');\n\n                if (!focusedButton) {\n                    const activeElement = document.activeElement && document.activeElement.nodeName ? document.activeElement.nodeName.toLocaleLowerCase() : false;\n                    if (activeElement == 'input' || activeElement == 'textarea' || activeElement == 'button') {\n                        return;\n                    }\n                }\n\n                event.preventDefault();\n                const btns = document.querySelectorAll('.gbtn[data-taborder]');\n                if (!btns || btns.length <= 0) {\n                    return;\n                }\n\n                if (!focusedButton) {\n                    const first = getNextFocusElement();\n                    if (first) {\n                        first.focus();\n                        addClass(first, 'focused');\n                    }\n                    return;\n                }\n\n                let currentFocusOrder = focusedButton.getAttribute('data-taborder');\n                let nextFocus = getNextFocusElement(currentFocusOrder);\n\n                removeClass(focusedButton, 'focused');\n\n                if (nextFocus) {\n                    nextFocus.focus();\n                    addClass(nextFocus, 'focused');\n                }\n            }\n            if (key == 39) {\n                instance.nextSlide();\n            }\n            if (key == 37) {\n                instance.prevSlide();\n            }\n            if (key == 27) {\n                instance.close();\n            }\n        }\n    });\n}\n","const uid = Date.now();\n\n/**\n * Merge two or more objects\n */\nexport function extend() {\n    let extended = {};\n    let deep = true;\n    let i = 0;\n    let length = arguments.length;\n    if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {\n        deep = arguments[0];\n        i++;\n    }\n    let merge = (obj) => {\n        for (let prop in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n                if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {\n                    extended[prop] = extend(true, extended[prop], obj[prop]);\n                } else {\n                    extended[prop] = obj[prop];\n                }\n            }\n        }\n    };\n    for (; i < length; i++) {\n        let obj = arguments[i];\n        merge(obj);\n    }\n    return extended;\n}\n\n/**\n * Each\n *\n * @param {mixed} node list, array, object\n * @param {function} callback\n */\nexport function each(collection, callback) {\n    if (isNode(collection) || collection === window || collection === document) {\n        collection = [collection];\n    }\n    if (!isArrayLike(collection) && !isObject(collection)) {\n        collection = [collection];\n    }\n    if (size(collection) == 0) {\n        return;\n    }\n\n    if (isArrayLike(collection) && !isObject(collection)) {\n        let l = collection.length,\n            i = 0;\n        for (; i < l; i++) {\n            if (callback.call(collection[i], collection[i], i, collection) === false) {\n                break;\n            }\n        }\n    } else if (isObject(collection)) {\n        for (let key in collection) {\n            if (has(collection, key)) {\n                if (callback.call(collection[key], collection[key], key, collection) === false) {\n                    break;\n                }\n            }\n        }\n    }\n}\n\n/**\n * Get nde events\n * return node events and optionally\n * check if the node has already a specific event\n * to avoid duplicated callbacks\n *\n * @param {node} node\n * @param {string} name event name\n * @param {object} fn callback\n * @returns {object}\n */\nexport function getNodeEvents(node, name = null, fn = null) {\n    const cache = (node[uid] = node[uid] || []);\n    const data = { all: cache, evt: null, found: null };\n    if (name && fn && size(cache) > 0) {\n        each(cache, (cl, i) => {\n            if (cl.eventName == name && cl.fn.toString() == fn.toString()) {\n                data.found = true;\n                data.evt = i;\n                return false;\n            }\n        });\n    }\n    return data;\n}\n\n/**\n * Add Event\n * Add an event listener\n *\n * @param {string} eventName\n * @param {object} detials\n */\nexport function addEvent(eventName, { onElement, withCallback, avoidDuplicate = true, once = false, useCapture = false } = {}, thisArg) {\n    let element = onElement || [];\n    if (isString(element)) {\n        element = document.querySelectorAll(element);\n    }\n\n    function handler(event) {\n        if (isFunction(withCallback)) {\n            withCallback.call(thisArg, event, this);\n        }\n        if (once) {\n            handler.destroy();\n        }\n    }\n    handler.destroy = function () {\n        each(element, (el) => {\n            const events = getNodeEvents(el, eventName, handler);\n            if (events.found) {\n                events.all.splice(events.evt, 1);\n            }\n            if (el.removeEventListener) {\n                el.removeEventListener(eventName, handler, useCapture);\n            }\n        });\n    };\n    each(element, (el) => {\n        const events = getNodeEvents(el, eventName, handler);\n        if ((el.addEventListener && avoidDuplicate && !events.found) || !avoidDuplicate) {\n            el.addEventListener(eventName, handler, useCapture);\n            events.all.push({ eventName: eventName, fn: handler });\n        }\n    });\n    return handler;\n}\n\n/**\n * Add element class\n *\n * @param {node} element\n * @param {string} class name\n */\nexport function addClass(node, name) {\n    each(name.split(' '), (cl) => node.classList.add(cl));\n}\n\n/**\n * Remove element class\n *\n * @param {node} element\n * @param {string} class name\n */\nexport function removeClass(node, name) {\n    each(name.split(' '), (cl) => node.classList.remove(cl));\n}\n\n/**\n * Has class\n *\n * @param {node} element\n * @param {string} class name\n */\nexport function hasClass(node, name) {\n    return node.classList.contains(name);\n}\n\n/**\n * Get the closestElement\n *\n * @param {node} element\n * @param {string} class name\n */\nexport function closest(elem, selector) {\n    while (elem !== document.body) {\n        elem = elem.parentElement;\n        if (!elem) {\n            return false;\n        }\n        const matches = typeof elem.matches == 'function' ? elem.matches(selector) : elem.msMatchesSelector(selector);\n\n        if (matches) {\n            return elem;\n        }\n    }\n}\n\n/**\n * CSS Animations\n *\n * @param {node} element\n * @param {string} animation name\n * @param {function} callback\n */\nexport function animateElement(element, animation = '', callback = false) {\n    if (!element || animation === '') {\n        return false;\n    }\n    if (animation === 'none') {\n        if (isFunction(callback)) {\n            callback();\n        }\n        return false;\n    }\n    const animationEnd = whichAnimationEvent();\n    const animationNames = animation.split(' ');\n    each(animationNames, (name) => {\n        addClass(element, 'g' + name);\n    });\n    addEvent(animationEnd, {\n        onElement: element,\n        avoidDuplicate: false,\n        once: true,\n        withCallback: (event, target) => {\n            each(animationNames, (name) => {\n                removeClass(target, 'g' + name);\n            });\n            if (isFunction(callback)) {\n                callback();\n            }\n        }\n    });\n}\n\nexport function cssTransform(node, translate = '') {\n    if (translate === '') {\n        node.style.webkitTransform = '';\n        node.style.MozTransform = '';\n        node.style.msTransform = '';\n        node.style.OTransform = '';\n        node.style.transform = '';\n        return false;\n    }\n    node.style.webkitTransform = translate;\n    node.style.MozTransform = translate;\n    node.style.msTransform = translate;\n    node.style.OTransform = translate;\n    node.style.transform = translate;\n}\n\n/**\n * Show element\n *\n * @param {node} element\n */\nexport function show(element) {\n    element.style.display = 'block';\n}\n\n/**\n * Hide element\n */\nexport function hide(element) {\n    element.style.display = 'none';\n}\n\n/**\n * Create a document fragment\n *\n * @param {string} html code\n */\nexport function createHTML(htmlStr) {\n    let frag = document.createDocumentFragment(),\n        temp = document.createElement('div');\n    temp.innerHTML = htmlStr;\n    while (temp.firstChild) {\n        frag.appendChild(temp.firstChild);\n    }\n    return frag;\n}\n\n/**\n * Return screen size\n * return the current screen dimensions\n *\n * @returns {object}\n */\nexport function windowSize() {\n    return {\n        width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,\n        height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight\n    };\n}\n\n/**\n * Determine animation events\n */\nexport function whichAnimationEvent() {\n    let t,\n        el = document.createElement('fakeelement');\n    let animations = {\n        animation: 'animationend',\n        OAnimation: 'oAnimationEnd',\n        MozAnimation: 'animationend',\n        WebkitAnimation: 'webkitAnimationEnd'\n    };\n    for (t in animations) {\n        if (el.style[t] !== undefined) {\n            return animations[t];\n        }\n    }\n}\n\n/**\n * Determine transition events\n */\nexport function whichTransitionEvent() {\n    let t,\n        el = document.createElement('fakeelement');\n\n    const transitions = {\n        transition: 'transitionend',\n        OTransition: 'oTransitionEnd',\n        MozTransition: 'transitionend',\n        WebkitTransition: 'webkitTransitionEnd'\n    };\n\n    for (t in transitions) {\n        if (el.style[t] !== undefined) {\n            return transitions[t];\n        }\n    }\n}\n\n/**\n * Create an iframe element\n *\n * @param {string} url\n * @param {numeric} width\n * @param {numeric} height\n * @param {function} callback\n */\nexport function createIframe(config) {\n    let { url, allow, callback, appendTo } = config;\n    let iframe = document.createElement('iframe');\n    iframe.className = 'vimeo-video gvideo';\n    iframe.src = url;\n    iframe.style.width = '100%';\n    iframe.style.height = '100%';\n\n    if (allow) {\n        iframe.setAttribute('allow', allow);\n    }\n    iframe.onload = function () {\n        iframe.onload = null;\n        addClass(iframe, 'node-ready');\n        if (isFunction(callback)) {\n            callback();\n        }\n    };\n\n    if (appendTo) {\n        appendTo.appendChild(iframe);\n    }\n    return iframe;\n}\n\n/**\n * Wait until\n * wait until all the validations\n * are passed\n *\n * @param {function} check\n * @param {function} onComplete\n * @param {numeric} delay\n * @param {numeric} timeout\n */\nexport function waitUntil(check, onComplete, delay, timeout) {\n    if (check()) {\n        onComplete();\n        return;\n    }\n\n    if (!delay) {\n        delay = 100;\n    }\n    let timeoutPointer;\n    let intervalPointer = setInterval(() => {\n        if (!check()) {\n            return;\n        }\n        clearInterval(intervalPointer);\n        if (timeoutPointer) {\n            clearTimeout(timeoutPointer);\n        }\n        onComplete();\n    }, delay);\n    if (timeout) {\n        timeoutPointer = setTimeout(() => {\n            clearInterval(intervalPointer);\n        }, timeout);\n    }\n}\n\n/**\n * Inject videos api\n * used for video player\n *\n * @param {string} url\n * @param {function} callback\n */\nexport function injectAssets(url, waitFor, callback) {\n    if (isNil(url)) {\n        console.error('Inject assets error');\n        return;\n    }\n    if (isFunction(waitFor)) {\n        callback = waitFor;\n        waitFor = false;\n    }\n\n    if (isString(waitFor) && waitFor in window) {\n        if (isFunction(callback)) {\n            callback();\n        }\n        return;\n    }\n\n    let found;\n\n    if (url.indexOf('.css') !== -1) {\n        found = document.querySelectorAll('link[href=\"' + url + '\"]');\n        if (found && found.length > 0) {\n            if (isFunction(callback)) {\n                callback();\n            }\n            return;\n        }\n\n        const head = document.getElementsByTagName('head')[0];\n        const headStyles = head.querySelectorAll('link[rel=\"stylesheet\"]');\n        const link = document.createElement('link');\n\n        link.rel = 'stylesheet';\n        link.type = 'text/css';\n        link.href = url;\n        link.media = 'all';\n\n        if (headStyles) {\n            head.insertBefore(link, headStyles[0]);\n        } else {\n            head.appendChild(link);\n        }\n        if (isFunction(callback)) {\n            callback();\n        }\n        return;\n    }\n\n    found = document.querySelectorAll('script[src=\"' + url + '\"]');\n    if (found && found.length > 0) {\n        if (isFunction(callback)) {\n            if (isString(waitFor)) {\n                waitUntil(\n                    () => {\n                        return typeof window[waitFor] !== 'undefined';\n                    },\n                    () => {\n                        callback();\n                    }\n                );\n                return false;\n            }\n            callback();\n        }\n        return;\n    }\n\n    let script = document.createElement('script');\n    script.type = 'text/javascript';\n    script.src = url;\n    script.onload = () => {\n        if (isFunction(callback)) {\n            if (isString(waitFor)) {\n                waitUntil(\n                    () => {\n                        return typeof window[waitFor] !== 'undefined';\n                    },\n                    () => {\n                        callback();\n                    }\n                );\n                return false;\n            }\n            callback();\n        }\n    };\n    document.body.appendChild(script);\n}\n\nexport function isMobile() {\n    return 'navigator' in window && window.navigator.userAgent.match(/(iPad)|(iPhone)|(iPod)|(Android)|(PlayBook)|(BB10)|(BlackBerry)|(Opera Mini)|(IEMobile)|(webOS)|(MeeGo)/i);\n}\n\nexport function isTouch() {\n    return isMobile() !== null || document.createTouch !== undefined || 'ontouchstart' in window || 'onmsgesturechange' in window || navigator.msMaxTouchPoints;\n}\n\nexport function isFunction(f) {\n    return typeof f === 'function';\n}\nexport function isString(s) {\n    return typeof s === 'string';\n}\nexport function isNode(el) {\n    return !!(el && el.nodeType && el.nodeType == 1);\n}\nexport function isArray(ar) {\n    return Array.isArray(ar);\n}\nexport function isArrayLike(ar) {\n    return ar && ar.length && isFinite(ar.length);\n}\nexport function isObject(o) {\n    let type = typeof o;\n    return type === 'object' && o != null && !isFunction(o) && !isArray(o);\n}\nexport function isNil(o) {\n    return o == null;\n}\nexport function has(obj, key) {\n    return obj !== null && hasOwnProperty.call(obj, key);\n}\nexport function size(o) {\n    if (isObject(o)) {\n        if (o.keys) {\n            return o.keys().length;\n        }\n        let l = 0;\n        for (let k in o) {\n            if (has(o, k)) {\n                l++;\n            }\n        }\n        return l;\n    } else {\n        return o.length;\n    }\n}\nexport function isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n}\n","/**\n * Slide\n * class to hablde slide creation\n * and config parser\n */\n\nimport ZoomImages from './zoom.js';\nimport DragSlides from './drag.js';\nimport slideImage from '../slides/image.js';\nimport slideVideo from '../slides/video.js';\nimport slideInline from '../slides/inline.js';\nimport slideIframe from '../slides/iframe.js';\nimport SlideConfigParser from './slide-parser.js';\nimport { addEvent, addClass, removeClass, hasClass, closest, isMobile, isFunction, isNode, createHTML } from '../utils/helpers.js';\n\nexport default class Slide {\n    constructor(el, instance, index) {\n        this.element = el;\n        this.instance = instance;\n        this.index = index;\n    }\n\n    /**\n     * Set slide content\n     *\n     * @param {node} slide\n     * @param {object} data\n     * @param {function} callback\n     */\n    setContent(slide = null, callback = false) {\n        if (hasClass(slide, 'loaded')) {\n            return false;\n        }\n\n        const settings = this.instance.settings;\n        const slideConfig = this.slideConfig;\n        const isMobileDevice = isMobile();\n\n        if (isFunction(settings.beforeSlideLoad)) {\n            settings.beforeSlideLoad({\n                index: this.index,\n                slide: slide,\n                player: false\n            });\n        }\n\n        let type = slideConfig.type;\n        let position = slideConfig.descPosition;\n        let slideMedia = slide.querySelector('.gslide-media');\n        let slideTitle = slide.querySelector('.gslide-title');\n        let slideText = slide.querySelector('.gslide-desc');\n        let slideDesc = slide.querySelector('.gdesc-inner');\n        let finalCallback = callback;\n\n        // used for image accessiblity\n        let titleID = 'gSlideTitle_' + this.index;\n        let textID = 'gSlideDesc_' + this.index;\n\n        if (isFunction(settings.afterSlideLoad)) {\n            finalCallback = () => {\n                if (isFunction(callback)) {\n                    callback();\n                }\n                settings.afterSlideLoad({\n                    index: this.index,\n                    slide: slide,\n                    player: this.instance.getSlidePlayerInstance(this.index)\n                });\n            };\n        }\n\n        if (slideConfig.title == '' && slideConfig.description == '') {\n            if (slideDesc) {\n                slideDesc.parentNode.parentNode.removeChild(slideDesc.parentNode);\n            }\n        } else {\n            if (slideTitle && slideConfig.title !== '') {\n                slideTitle.id = titleID;\n                slideTitle.innerHTML = slideConfig.title;\n            } else {\n                slideTitle.parentNode.removeChild(slideTitle);\n            }\n            if (slideText && slideConfig.description !== '') {\n                slideText.id = textID;\n                if (isMobileDevice && settings.moreLength > 0) {\n                    slideConfig.smallDescription = this.slideShortDesc(slideConfig.description, settings.moreLength, settings.moreText);\n                    slideText.innerHTML = slideConfig.smallDescription;\n                    this.descriptionEvents(slideText, slideConfig);\n                } else {\n                    slideText.innerHTML = slideConfig.description;\n                }\n            } else {\n                slideText.parentNode.removeChild(slideText);\n            }\n            addClass(slideMedia.parentNode, `desc-${position}`);\n            addClass(slideDesc.parentNode, `description-${position}`);\n        }\n\n        addClass(slideMedia, `gslide-${type}`);\n        addClass(slide, 'loaded');\n\n        if (type === 'video') {\n            slideVideo.apply(this.instance, [slide, slideConfig, this.index, finalCallback]);\n            return;\n        }\n\n        if (type === 'external') {\n            slideIframe.apply(this, [slide, slideConfig, this.index, finalCallback]);\n            return;\n        }\n\n        if (type === 'inline') {\n            slideInline.apply(this.instance, [slide, slideConfig, this.index, finalCallback]);\n            if (slideConfig.draggable) {\n                new DragSlides({\n                    dragEl: slide.querySelector('.gslide-inline'),\n                    toleranceX: settings.dragToleranceX,\n                    toleranceY: settings.dragToleranceY,\n                    slide: slide,\n                    instance: this.instance\n                });\n            }\n            return;\n        }\n\n        if (type === 'image') {\n            slideImage(slide, slideConfig, this.index, () => {\n                const img = slide.querySelector('img');\n\n                if (slideConfig.draggable) {\n                    new DragSlides({\n                        dragEl: img,\n                        toleranceX: settings.dragToleranceX,\n                        toleranceY: settings.dragToleranceY,\n                        slide: slide,\n                        instance: this.instance\n                    });\n                }\n                if (slideConfig.zoomable && img.naturalWidth > img.offsetWidth) {\n                    addClass(img, 'zoomable');\n                    new ZoomImages(img, slide, () => {\n                        this.instance.resize();\n                    });\n                }\n\n                if (isFunction(finalCallback)) {\n                    finalCallback();\n                }\n            });\n            return;\n        }\n\n        if (isFunction(finalCallback)) {\n            finalCallback();\n        }\n    }\n\n    slideShortDesc(string, n = 50, wordBoundary = false) {\n        let div = document.createElement('div');\n        div.innerHTML = string;\n        let cleanedString = div.innerText;\n\n        let useWordBoundary = wordBoundary;\n        string = cleanedString.trim();\n        if (string.length <= n) {\n            return string;\n        }\n        let subString = string.substr(0, n - 1);\n        if (!useWordBoundary) {\n            return subString;\n        }\n\n        div = null;\n        return subString + '... <a href=\"#\" class=\"desc-more\">' + wordBoundary + '</a>';\n    }\n\n    descriptionEvents(desc, data) {\n        let moreLink = desc.querySelector('.desc-more');\n        if (!moreLink) {\n            return false;\n        }\n\n        addEvent('click', {\n            onElement: moreLink,\n            withCallback: (event, target) => {\n                event.preventDefault();\n                const body = document.body;\n\n                let desc = closest(target, '.gslide-desc');\n                if (!desc) {\n                    return false;\n                }\n\n                desc.innerHTML = data.description;\n                addClass(body, 'gdesc-open');\n\n                let shortEvent = addEvent('click', {\n                    onElement: [body, closest(desc, '.gslide-description')],\n                    withCallback: (event, target) => {\n                        if (event.target.nodeName.toLowerCase() !== 'a') {\n                            removeClass(body, 'gdesc-open');\n                            addClass(body, 'gdesc-closed');\n                            desc.innerHTML = data.smallDescription;\n                            this.descriptionEvents(desc, data);\n\n                            setTimeout(() => {\n                                removeClass(body, 'gdesc-closed');\n                            }, 400);\n                            shortEvent.destroy();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Create Slide Node\n     *\n     * @return { node }\n     */\n    create() {\n        return createHTML(this.instance.settings.slideHTML);\n    }\n\n    /**\n     * Get slide config\n     * returns each individual slide config\n     * it uses SlideConfigParser\n     * each slide can overwrite a global setting\n     * read more in the SlideConfigParser class\n     *\n     * @return { object }\n     */\n    getConfig() {\n        if (!isNode(this.element) && !this.element.hasOwnProperty('draggable')) {\n            this.element.draggable = this.instance.settings.draggable;\n        }\n\n        const parser = new SlideConfigParser(this.instance.settings.slideExtraAttributes);\n        this.slideConfig = parser.parseConfig(this.element, this.instance.settings);\n\n        return this.slideConfig;\n    }\n}\n","/**\n * ZoomImages\n * Allow imaes to zoom and drag\n * for desktops\n *\n * @param {node} img node\n * @param {node} slide container\n * @param {function} function to trigger on close\n */\nexport default class ZoomImages {\n    constructor(el, slide, onclose = null) {\n        this.img = el;\n        this.slide = slide;\n        this.onclose = onclose;\n\n        if (this.img.setZoomEvents) {\n            return false;\n        }\n\n        this.active = false;\n        this.zoomedIn = false;\n        this.dragging = false;\n        this.currentX = null;\n        this.currentY = null;\n        this.initialX = null;\n        this.initialY = null;\n        this.xOffset = 0;\n        this.yOffset = 0;\n\n        this.img.addEventListener('mousedown', (e) => this.dragStart(e), false);\n        this.img.addEventListener('mouseup', (e) => this.dragEnd(e), false);\n        this.img.addEventListener('mousemove', (e) => this.drag(e), false);\n\n        this.img.addEventListener(\n            'click',\n            (e) => {\n                if (this.slide.classList.contains('dragging-nav')) {\n                    this.zoomOut();\n                    return false;\n                }\n\n                if (!this.zoomedIn) {\n                    return this.zoomIn();\n                }\n                if (this.zoomedIn && !this.dragging) {\n                    this.zoomOut();\n                }\n            },\n            false\n        );\n\n        this.img.setZoomEvents = true;\n    }\n    zoomIn() {\n        let winWidth = this.widowWidth();\n\n        if (this.zoomedIn || winWidth <= 768) {\n            return;\n        }\n\n        const img = this.img;\n        img.setAttribute('data-style', img.getAttribute('style'));\n        img.style.maxWidth = img.naturalWidth + 'px';\n        img.style.maxHeight = img.naturalHeight + 'px';\n\n        if (img.naturalWidth > winWidth) {\n            let centerX = winWidth / 2 - img.naturalWidth / 2;\n            this.setTranslate(this.img.parentNode, centerX, 0);\n        }\n        this.slide.classList.add('zoomed');\n        this.zoomedIn = true;\n    }\n    zoomOut() {\n        this.img.parentNode.setAttribute('style', '');\n        this.img.setAttribute('style', this.img.getAttribute('data-style'));\n        this.slide.classList.remove('zoomed');\n        this.zoomedIn = false;\n        this.currentX = null;\n        this.currentY = null;\n        this.initialX = null;\n        this.initialY = null;\n        this.xOffset = 0;\n        this.yOffset = 0;\n\n        if (this.onclose && typeof this.onclose == 'function') {\n            this.onclose();\n        }\n    }\n    dragStart(e) {\n        e.preventDefault();\n        if (!this.zoomedIn) {\n            this.active = false;\n            return;\n        }\n        if (e.type === 'touchstart') {\n            this.initialX = e.touches[0].clientX - this.xOffset;\n            this.initialY = e.touches[0].clientY - this.yOffset;\n        } else {\n            this.initialX = e.clientX - this.xOffset;\n            this.initialY = e.clientY - this.yOffset;\n        }\n\n        if (e.target === this.img) {\n            this.active = true;\n            this.img.classList.add('dragging');\n        }\n    }\n    dragEnd(e) {\n        e.preventDefault();\n        this.initialX = this.currentX;\n        this.initialY = this.currentY;\n        this.active = false;\n\n        setTimeout(() => {\n            this.dragging = false;\n            this.img.isDragging = false;\n            this.img.classList.remove('dragging');\n        }, 100);\n    }\n    drag(e) {\n        if (this.active) {\n            e.preventDefault();\n\n            if (e.type === 'touchmove') {\n                this.currentX = e.touches[0].clientX - this.initialX;\n                this.currentY = e.touches[0].clientY - this.initialY;\n            } else {\n                this.currentX = e.clientX - this.initialX;\n                this.currentY = e.clientY - this.initialY;\n            }\n\n            this.xOffset = this.currentX;\n            this.yOffset = this.currentY;\n\n            this.img.isDragging = true;\n            this.dragging = true;\n\n            this.setTranslate(this.img, this.currentX, this.currentY);\n        }\n    }\n    onMove(e) {\n        if (!this.zoomedIn) {\n            return;\n        }\n        let xOffset = e.clientX - this.img.naturalWidth / 2;\n        let yOffset = e.clientY - this.img.naturalHeight / 2;\n\n        this.setTranslate(this.img, xOffset, yOffset);\n    }\n    setTranslate(node, xPos, yPos) {\n        node.style.transform = 'translate3d(' + xPos + 'px, ' + yPos + 'px, 0)';\n    }\n    widowWidth() {\n        return window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n    }\n}\n","/**\n * DragSlides\n * Allow imaes to be dragged for prev and next\n * in desktops\n *\n * @param { object } config\n */\n\nimport { closest } from '../utils/helpers.js';\n\nexport default class DragSlides {\n    constructor(config = {}) {\n        let { dragEl, toleranceX = 40, toleranceY = 65, slide = null, instance = null } = config;\n\n        this.el = dragEl;\n        this.active = false;\n        this.dragging = false;\n        this.currentX = null;\n        this.currentY = null;\n        this.initialX = null;\n        this.initialY = null;\n        this.xOffset = 0;\n        this.yOffset = 0;\n        this.direction = null;\n        this.lastDirection = null;\n        this.toleranceX = toleranceX;\n        this.toleranceY = toleranceY;\n        this.toleranceReached = false;\n        this.dragContainer = this.el;\n        this.slide = slide;\n        this.instance = instance;\n\n        this.el.addEventListener('mousedown', (e) => this.dragStart(e), false);\n        this.el.addEventListener('mouseup', (e) => this.dragEnd(e), false);\n        this.el.addEventListener('mousemove', (e) => this.drag(e), false);\n    }\n    dragStart(e) {\n        if (this.slide.classList.contains('zoomed')) {\n            this.active = false;\n            return;\n        }\n\n        if (e.type === 'touchstart') {\n            this.initialX = e.touches[0].clientX - this.xOffset;\n            this.initialY = e.touches[0].clientY - this.yOffset;\n        } else {\n            this.initialX = e.clientX - this.xOffset;\n            this.initialY = e.clientY - this.yOffset;\n        }\n\n        let clicked = e.target.nodeName.toLowerCase();\n        let exludeClicks = ['input', 'select', 'textarea', 'button', 'a'];\n        if (\n            e.target.classList.contains('nodrag') ||\n            closest(e.target, '.nodrag') ||\n            exludeClicks.indexOf(clicked) !== -1\n        ) {\n            this.active = false;\n            return;\n        }\n\n        e.preventDefault();\n\n        if (e.target === this.el || (clicked !== 'img' && closest(e.target, '.gslide-inline'))) {\n            this.active = true;\n            this.el.classList.add('dragging');\n            this.dragContainer = closest(e.target, '.ginner-container');\n        }\n    }\n    dragEnd(e) {\n        e && e.preventDefault();\n        this.initialX = 0;\n        this.initialY = 0;\n        this.currentX = null;\n        this.currentY = null;\n        this.initialX = null;\n        this.initialY = null;\n        this.xOffset = 0;\n        this.yOffset = 0;\n        this.active = false;\n\n        if (this.doSlideChange) {\n            this.instance.preventOutsideClick = true;\n            this.doSlideChange == 'right' && this.instance.prevSlide();\n            this.doSlideChange == 'left' && this.instance.nextSlide();\n        }\n\n        if (this.doSlideClose) {\n            this.instance.close();\n        }\n\n        if (!this.toleranceReached) {\n            this.setTranslate(this.dragContainer, 0, 0, true);\n        }\n\n        setTimeout(() => {\n            this.instance.preventOutsideClick = false;\n            this.toleranceReached = false;\n            this.lastDirection = null;\n            this.dragging = false;\n            this.el.isDragging = false;\n            this.el.classList.remove('dragging');\n            this.slide.classList.remove('dragging-nav');\n            this.dragContainer.style.transform = '';\n            this.dragContainer.style.transition = '';\n        }, 100);\n    }\n    drag(e) {\n        if (this.active) {\n            e.preventDefault();\n\n            this.slide.classList.add('dragging-nav');\n\n            if (e.type === 'touchmove') {\n                this.currentX = e.touches[0].clientX - this.initialX;\n                this.currentY = e.touches[0].clientY - this.initialY;\n            } else {\n                this.currentX = e.clientX - this.initialX;\n                this.currentY = e.clientY - this.initialY;\n            }\n\n            this.xOffset = this.currentX;\n            this.yOffset = this.currentY;\n\n            this.el.isDragging = true;\n            this.dragging = true;\n            this.doSlideChange = false;\n            this.doSlideClose = false;\n\n            let currentXInt = Math.abs(this.currentX);\n            let currentYInt = Math.abs(this.currentY);\n\n            // Horizontal drag\n            if (\n                currentXInt > 0 &&\n                currentXInt >= Math.abs(this.currentY) &&\n                (!this.lastDirection || this.lastDirection == 'x')\n            ) {\n                this.yOffset = 0;\n                this.lastDirection = 'x';\n                this.setTranslate(this.dragContainer, this.currentX, 0);\n\n                let doChange = this.shouldChange();\n                if (!this.instance.settings.dragAutoSnap && doChange) {\n                    this.doSlideChange = doChange;\n                }\n\n                if (this.instance.settings.dragAutoSnap && doChange) {\n                    this.instance.preventOutsideClick = true;\n                    this.toleranceReached = true;\n                    this.active = false;\n                    this.instance.preventOutsideClick = true;\n                    this.dragEnd(null);\n                    doChange == 'right' && this.instance.prevSlide();\n                    doChange == 'left' && this.instance.nextSlide();\n                    return;\n                }\n            }\n\n            // Vertical drag\n            if (\n                this.toleranceY > 0 &&\n                currentYInt > 0 &&\n                currentYInt >= currentXInt &&\n                (!this.lastDirection || this.lastDirection == 'y')\n            ) {\n                this.xOffset = 0;\n                this.lastDirection = 'y';\n                this.setTranslate(this.dragContainer, 0, this.currentY);\n\n                let doClose = this.shouldClose();\n\n                if (!this.instance.settings.dragAutoSnap && doClose) {\n                    this.doSlideClose = true;\n                }\n                if (this.instance.settings.dragAutoSnap && doClose) {\n                    this.instance.close();\n                }\n                return;\n            }\n        }\n    }\n\n    shouldChange() {\n        let doChange = false;\n        let currentXInt = Math.abs(this.currentX);\n\n        if (currentXInt >= this.toleranceX) {\n            let dragDir = this.currentX > 0 ? 'right' : 'left';\n\n            if (\n                (dragDir == 'left' && this.slide !== this.slide.parentNode.lastChild) ||\n                (dragDir == 'right' && this.slide !== this.slide.parentNode.firstChild)\n            ) {\n                doChange = dragDir;\n            }\n        }\n        return doChange;\n    }\n\n    shouldClose() {\n        let doClose = false;\n        let currentYInt = Math.abs(this.currentY);\n\n        if (currentYInt >= this.toleranceY) {\n            doClose = true;\n        }\n        return doClose;\n    }\n\n    setTranslate(node, xPos, yPos, animated = false) {\n        if (animated) {\n            node.style.transition = 'all .2s ease';\n        } else {\n            node.style.transition = '';\n        }\n        node.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;\n    }\n}\n","/**\n * Set slide inline content\n * we'll extend this to make http\n * requests using the fetch api\n * but for now we keep it simple\n *\n * @param {node} slide\n * @param {object} data\n * @param {int} index\n * @param {function} callback\n */\n\nimport { isNil, isFunction } from '../utils/helpers.js';\n\nexport default function slideImage(slide, data, index, callback) {\n    const slideMedia = slide.querySelector('.gslide-media');\n\n    let img = new Image();\n    let titleID = 'gSlideTitle_' + index;\n    let textID = 'gSlideDesc_' + index;\n\n    // prettier-ignore\n    img.addEventListener('load', () => {\n        if (isFunction(callback)) {\n            callback();\n        }\n    }, false);\n\n    img.src = data.href;\n    if (data.sizes != '' && data.srcset != '') {\n        img.sizes = data.sizes;\n        img.srcset = data.srcset;\n    }\n    img.alt = ''; // https://davidwalsh.name/accessibility-tip-empty-alt-attributes\n    if (!isNil(data.alt) && data.alt !== '') {\n        img.alt = data.alt;\n    }\n\n    if (data.title !== '') {\n        img.setAttribute('aria-labelledby', titleID);\n    }\n    if (data.description !== '') {\n        // https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-describedby_attribute#Example_2_A_Close_Button\n        img.setAttribute('aria-describedby', textID);\n    }\n\n    if (data.hasOwnProperty('_hasCustomWidth') && data._hasCustomWidth) {\n        img.style.width = data.width;\n    }\n    if (data.hasOwnProperty('_hasCustomHeight') && data._hasCustomHeight) {\n        img.style.height = data.height;\n    }\n\n    slideMedia.insertBefore(img, slideMedia.firstChild);\n    return;\n}\n","/**\n * Set slide video\n *\n * @param {node} slide\n * @param {object} data\n * @param {int} index\n * @param {function} callback\n */\nimport { has, closest, injectAssets, addClass, removeClass, createHTML, isFunction, waitUntil } from '../utils/helpers.js';\n\nexport default function slideVideo(slide, data, index, callback) {\n    const slideContainer = slide.querySelector('.ginner-container');\n    const videoID = 'gvideo' + index;\n    const slideMedia = slide.querySelector('.gslide-media');\n    const videoPlayers = this.getAllPlayers();\n\n    addClass(slideContainer, 'gvideo-container');\n\n    slideMedia.insertBefore(createHTML('<div class=\"gvideo-wrapper\"></div>'), slideMedia.firstChild);\n\n    const videoWrapper = slide.querySelector('.gvideo-wrapper');\n\n    injectAssets(this.settings.plyr.css, 'Plyr');\n\n    let url = data.href;\n    let provider = data?.videoProvider;\n    let customPlaceholder = false;\n\n    slideMedia.style.maxWidth = data.width;\n\n    injectAssets(this.settings.plyr.js, 'Plyr', () => {\n        // Set vimeo videos\n        if (!provider && url.match(/vimeo\\.com\\/([0-9]*)/)) {\n            provider = 'vimeo';\n        }\n\n        // Set youtube videos\n        if (\n            !provider &&\n            (url.match(/(youtube\\.com|youtube-nocookie\\.com)\\/watch\\?v=([a-zA-Z0-9\\-_]+)/) || url.match(/youtu\\.be\\/([a-zA-Z0-9\\-_]+)/) || url.match(/(youtube\\.com|youtube-nocookie\\.com)\\/embed\\/([a-zA-Z0-9\\-_]+)/) || url.match(/(youtube\\.com|youtube-nocookie\\.com)\\/shorts\\/([a-zA-Z0-9\\-_]+)/))\n        ) {\n            provider = 'youtube';\n        }\n\n        // Set local videos\n        // if no provider, default to local\n        if (provider === 'local' || !provider) {\n            provider = 'local';\n            let html = '<video id=\"' + videoID + '\" ';\n            html += `style=\"background:#000; max-width: ${data.width};\" `;\n            html += 'preload=\"metadata\" ';\n            html += 'x-webkit-airplay=\"allow\" ';\n            html += 'playsinline ';\n            html += 'controls ';\n            html += 'class=\"gvideo-local\">';\n            html += `<source src=\"${url}\">`;\n            html += '</video>';\n            customPlaceholder = createHTML(html);\n        }\n\n        // prettier-ignore\n        const placeholder = customPlaceholder ? customPlaceholder : createHTML(`<div id=\"${videoID}\" data-plyr-provider=\"${provider}\" data-plyr-embed-id=\"${url}\"></div>`);\n\n        addClass(videoWrapper, `${provider}-video gvideo`);\n        videoWrapper.appendChild(placeholder);\n        videoWrapper.setAttribute('data-id', videoID);\n        videoWrapper.setAttribute('data-index', index);\n\n        const playerConfig = has(this.settings.plyr, 'config') ? this.settings.plyr.config : {};\n        const player = new Plyr('#' + videoID, playerConfig);\n\n        player.on('ready', (event) => {\n            videoPlayers[videoID] = event.detail.plyr;\n            if (isFunction(callback)) {\n                callback();\n            }\n        });\n        waitUntil(\n            () => {\n                return slide.querySelector('iframe') && slide.querySelector('iframe').dataset.ready == 'true';\n            },\n            () => {\n                this.resize(slide);\n            }\n        );\n        player.on('enterfullscreen', handleMediaFullScreen);\n        player.on('exitfullscreen', handleMediaFullScreen);\n    });\n}\n\n/**\n * Handle fullscreen\n *\n * @param {object} event\n */\nfunction handleMediaFullScreen(event) {\n    const media = closest(event.target, '.gslide-media');\n\n    if (event.type === 'enterfullscreen') {\n        addClass(media, 'fullscreen');\n    }\n    if (event.type === 'exitfullscreen') {\n        removeClass(media, 'fullscreen');\n    }\n}\n","/**\n * Set slide inline content\n * we'll extend this to make http\n * requests using the fetch api\n * but for now we keep it simple\n *\n * @param {node} slide\n * @param {object} data\n * @param {int} index\n * @param {function} callback\n */\n\nimport { has, addClass, addEvent, createHTML, isString, isNode, isFunction } from '../utils/helpers.js';\n\nexport default function slideInline(slide, data, index, callback) {\n    const slideMedia = slide.querySelector('.gslide-media');\n    const hash = has(data, 'href') && data.href ? data.href.split('#').pop().trim() : false;\n    const content = has(data, 'content') && data.content ? data.content : false;\n    let innerContent;\n\n    if (content) {\n        if (isString(content)) {\n            innerContent = createHTML(`<div class=\"ginlined-content\">${content}</div>`);\n        }\n        if (isNode(content)) {\n            if (content.style.display == 'none') {\n                content.style.display = 'block';\n            }\n\n            const container = document.createElement('div');\n            container.className = 'ginlined-content';\n            container.appendChild(content);\n            innerContent = container;\n        }\n    }\n\n    if (hash) {\n        let div = document.getElementById(hash);\n        if (!div) {\n            return false;\n        }\n        const cloned = div.cloneNode(true);\n\n        cloned.style.height = data.height;\n        cloned.style.maxWidth = data.width;\n        addClass(cloned, 'ginlined-content');\n        innerContent = cloned;\n    }\n\n    if (!innerContent) {\n        console.error('Unable to append inline slide content', data);\n        return false;\n    }\n\n    slideMedia.style.height = data.height;\n    slideMedia.style.width = data.width;\n    slideMedia.appendChild(innerContent);\n\n    this.events['inlineclose' + hash] = addEvent('click', {\n        onElement: slideMedia.querySelectorAll('.gtrigger-close'),\n        withCallback: (e) => {\n            e.preventDefault();\n            this.close();\n        }\n    });\n\n    if (isFunction(callback)) {\n        callback();\n    }\n    return;\n}\n","/**\n * Set slide iframe content\n *\n * @param {node} slide\n * @param {object} data\n * @param {int} index\n * @param {function} callback\n */\n\nimport { createIframe } from '../utils/helpers.js';\n\nexport default function slideIframe(slide, data, index, callback) {\n    const slideMedia = slide.querySelector('.gslide-media');\n    const iframe = createIframe({\n        url: data.href,\n        callback: callback\n    });\n\n    slideMedia.parentNode.style.maxWidth = data.width;\n    slideMedia.parentNode.style.height = data.height;\n    slideMedia.appendChild(iframe);\n\n    return;\n}\n","import { extend, has, each, isNil, isNode, isObject, isNumber } from '../utils/helpers.js';\n\nexport default class SlideConfigParser {\n    constructor(slideParamas = {}) {\n        this.defaults = {\n            href: '',\n            sizes: '',\n            srcset: '',\n            title: '',\n            type: '',\n            videoProvider: '',\n            description: '',\n            alt: '',\n            descPosition: 'bottom',\n            effect: '',\n            width: '',\n            height: '',\n            content: false,\n            zoomable: true,\n            draggable: true\n        };\n\n        if (isObject(slideParamas)) {\n            this.defaults = extend(this.defaults, slideParamas);\n        }\n    }\n\n    /**\n     * Get source type\n     * gte the source type of a url\n     *\n     * @param {string} url\n     */\n    sourceType(url) {\n        let origin = url;\n        url = url.toLowerCase();\n\n        if (url.match(/\\.(jpeg|jpg|jpe|gif|png|apn|webp|avif|svg)/) !== null) {\n            return 'image';\n        }\n        if (url.match(/(youtube\\.com|youtube-nocookie\\.com)\\/watch\\?v=([a-zA-Z0-9\\-_]+)/) || url.match(/youtu\\.be\\/([a-zA-Z0-9\\-_]+)/) || url.match(/(youtube\\.com|youtube-nocookie\\.com)\\/embed\\/([a-zA-Z0-9\\-_]+)/) || url.match(/(youtube\\.com|youtube-nocookie\\.com)\\/shorts\\/([a-zA-Z0-9\\-_]+)/)) {\n            return 'video';\n        }\n        if (url.match(/vimeo\\.com\\/([0-9]*)/)) {\n            return 'video';\n        }\n        if (url.match(/\\.(mp4|ogg|webm|mov)/) !== null) {\n            return 'video';\n        }\n        if (url.match(/\\.(mp3|wav|wma|aac|ogg)/) !== null) {\n            return 'audio';\n        }\n\n        // Check if inline content\n        if (url.indexOf('#') > -1) {\n            let hash = origin.split('#').pop();\n            if (hash.trim() !== '') {\n                return 'inline';\n            }\n        }\n        // Ajax\n        if (url.indexOf('goajax=true') > -1) {\n            return 'ajax';\n        }\n\n        return 'external';\n    }\n\n    parseConfig(element, settings) {\n        let data = extend({ descPosition: settings.descPosition }, this.defaults);\n\n        if (isObject(element) && !isNode(element)) {\n            if (!has(element, 'type')) {\n                if (has(element, 'content') && element.content) {\n                    element.type = 'inline';\n                } else if (has(element, 'href')) {\n                    element.type = this.sourceType(element.href);\n                }\n            }\n            let objectData = extend(data, element);\n            this.setSize(objectData, settings);\n\n            return objectData;\n        }\n\n        let url = '';\n        let config = element.getAttribute('data-glightbox');\n        let nodeType = element.nodeName.toLowerCase();\n\n        if (nodeType === 'a') {\n            url = element.href;\n        }\n        if (nodeType === 'img') {\n            url = element.src;\n            //alt attribute propagation\n            data.alt = element.alt;\n        }\n\n        data.href = url;\n\n        each(data, (val, key) => {\n            if (has(settings, key) && key !== 'width') {\n                data[key] = settings[key];\n            }\n            const nodeData = element.dataset[key];\n            if (!isNil(nodeData)) {\n                data[key] = this.sanitizeValue(nodeData);\n            }\n        });\n\n        if (data.content) {\n            data.type = 'inline';\n        }\n\n        if (!data.type && url) {\n            data.type = this.sourceType(url);\n        }\n\n        if (!isNil(config)) {\n            let cleanKeys = [];\n            each(data, (v, k) => {\n                cleanKeys.push(';\\\\s?' + k);\n            });\n            cleanKeys = cleanKeys.join('\\\\s?:|');\n            if (config.trim() !== '') {\n                each(data, (val, key) => {\n                    const str = config;\n                    const match = 's?' + key + 's?:s?(.*?)(' + cleanKeys + 's?:|$)';\n                    const regex = new RegExp(match);\n                    const matches = str.match(regex);\n\n                    if (matches && matches.length && matches[1]) {\n                        const value = matches[1].trim().replace(/;\\s*$/, '');\n                        data[key] = this.sanitizeValue(value);\n                    }\n                });\n            }\n        } else {\n            if (!data.title && nodeType == 'a') {\n                let title = element.title;\n                if (!isNil(title) && title !== '') {\n                    data.title = title;\n                }\n            }\n            if (!data.title && nodeType == 'img') {\n                let alt = element.alt;\n                if (!isNil(alt) && alt !== '') {\n                    data.title = alt;\n                }\n            }\n        }\n\n        // Try to get the description from a referenced element\n        if (data.description && data.description.substring(0, 1) === '.') {\n            let description;\n\n            try {\n                description = document.querySelector(data.description).innerHTML;\n            } catch (error) {\n                if (!(error instanceof DOMException)) {\n                    throw error;\n                }\n            }\n\n            if (description) {\n                data.description = description;\n            }\n        }\n\n        // Try to get the description from a .glightbox-desc element\n        if (!data.description) {\n            let nodeDesc = element.querySelector('.glightbox-desc');\n            if (nodeDesc) {\n                data.description = nodeDesc.innerHTML;\n            }\n        }\n\n        this.setSize(data, settings, element);\n        this.slideConfig = data;\n\n        return data;\n    }\n\n    /**\n     * Set slide data size\n     * set the correct size dependin\n     * on the slide type\n     *\n     * @param { object } data\n     * @param { object } settings\n     * @return { object }\n     */\n    setSize(data, settings, element = null) {\n        const defaultWith = data.type == 'video' ? this.checkSize(settings.videosWidth) : this.checkSize(settings.width);\n        const defaultHeight = this.checkSize(settings.height);\n\n        data.width = has(data, 'width') && data.width !== '' ? this.checkSize(data.width) : defaultWith;\n        data.height = has(data, 'height') && data.height !== '' ? this.checkSize(data.height) : defaultHeight;\n\n        if (element && data.type == 'image') {\n            data._hasCustomWidth = element.dataset.width ? true : false;\n            data._hasCustomHeight = element.dataset.height ? true : false;\n        }\n\n        return data;\n    }\n\n    /**\n     * [checkSize size\n     * check if the passed size has a correct unit\n     *\n     * @param {string} size\n     * @return {string}\n     */\n    checkSize(size) {\n        return isNumber(size) ? `${size}px` : size;\n    }\n\n    /**\n     * Sanitize data attributes value\n     *\n     * @param string val\n     * @return mixed\n     */\n    sanitizeValue(val) {\n        if (val !== 'true' && val !== 'false') {\n            return val;\n        }\n        return val === 'true';\n    }\n}\n","/**\n * Touch Navigation\n * Allow navigation using touch events\n *\n * @param {object} instance\n */\n\nimport TouchEvents from './touch-events.js';\nimport { addEvent, addClass, removeClass, hasClass, closest, whichTransitionEvent, cssTransform, windowSize } from '../utils/helpers.js';\n\nfunction resetSlideMove(slide) {\n    const transitionEnd = whichTransitionEvent();\n    const windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n\n    let media = hasClass(slide, 'gslide-media') ? slide : slide.querySelector('.gslide-media');\n    let container = closest(media, '.ginner-container');\n    let desc = slide.querySelector('.gslide-description');\n\n    if (windowWidth > 769) {\n        media = container;\n    }\n\n    addClass(media, 'greset');\n    cssTransform(media, 'translate3d(0, 0, 0)');\n    addEvent(transitionEnd, {\n        onElement: media,\n        once: true,\n        withCallback: (event, target) => {\n            removeClass(media, 'greset');\n        }\n    });\n\n    media.style.opacity = '';\n    if (desc) {\n        desc.style.opacity = '';\n    }\n}\n\nexport default function touchNavigation(instance) {\n    if (instance.events.hasOwnProperty('touch')) {\n        return false;\n    }\n\n    let winSize = windowSize();\n    let winWidth = winSize.width;\n    let winHeight = winSize.height;\n    let process = false;\n    let currentSlide = null;\n    let media = null;\n    let mediaImage = null;\n    let doingMove = false;\n    let initScale = 1;\n    let maxScale = 4.5;\n    let currentScale = 1;\n    let doingZoom = false;\n    let imageZoomed = false;\n    let zoomedPosX = null;\n    let zoomedPosY = null;\n    let lastZoomedPosX = null;\n    let lastZoomedPosY = null;\n    let hDistance;\n    let vDistance;\n    let hDistancePercent = 0;\n    let vDistancePercent = 0;\n    let vSwipe = false;\n    let hSwipe = false;\n    let startCoords = {};\n    let endCoords = {};\n    let xDown = 0;\n    let yDown = 0;\n    let isInlined;\n\n    const sliderWrapper = document.getElementById('glightbox-slider');\n    const overlay = document.querySelector('.goverlay');\n\n    const touchInstance = new TouchEvents(sliderWrapper, {\n        touchStart: (e) => {\n            process = true;\n\n            // TODO: More tests for inline content slides\n            if (hasClass(e.targetTouches[0].target, 'ginner-container') || closest(e.targetTouches[0].target, '.gslide-desc') || e.targetTouches[0].target.nodeName.toLowerCase() == 'a') {\n                process = false;\n            }\n\n            if (closest(e.targetTouches[0].target, '.gslide-inline') && !hasClass(e.targetTouches[0].target.parentNode, 'gslide-inline')) {\n                process = false;\n            }\n\n            if (process) {\n                endCoords = e.targetTouches[0];\n                startCoords.pageX = e.targetTouches[0].pageX;\n                startCoords.pageY = e.targetTouches[0].pageY;\n                xDown = e.targetTouches[0].clientX;\n                yDown = e.targetTouches[0].clientY;\n\n                currentSlide = instance.activeSlide;\n                media = currentSlide.querySelector('.gslide-media');\n                isInlined = currentSlide.querySelector('.gslide-inline');\n\n                mediaImage = null;\n                if (hasClass(media, 'gslide-image')) {\n                    mediaImage = media.querySelector('img');\n                }\n\n                const windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n\n                if (windowWidth > 769) {\n                    media = currentSlide.querySelector('.ginner-container');\n                }\n\n                removeClass(overlay, 'greset');\n\n                if (e.pageX > 20 && e.pageX < window.innerWidth - 20) {\n                    return;\n                }\n                e.preventDefault();\n            }\n        },\n        touchMove: (e) => {\n            if (!process) {\n                return;\n            }\n            endCoords = e.targetTouches[0];\n\n            if (doingZoom || imageZoomed) {\n                return;\n            }\n            if (isInlined && isInlined.offsetHeight > winHeight) {\n                // Allow scroll without moving the slide\n                const moved = startCoords.pageX - endCoords.pageX;\n                if (Math.abs(moved) <= 13) {\n                    return false;\n                }\n            }\n\n            doingMove = true;\n            let xUp = e.targetTouches[0].clientX;\n            let yUp = e.targetTouches[0].clientY;\n            let xDiff = xDown - xUp;\n            let yDiff = yDown - yUp;\n\n            if (Math.abs(xDiff) > Math.abs(yDiff)) {\n                vSwipe = false;\n                hSwipe = true;\n            } else {\n                hSwipe = false;\n                vSwipe = true;\n            }\n\n            hDistance = endCoords.pageX - startCoords.pageX;\n            hDistancePercent = (hDistance * 100) / winWidth;\n\n            vDistance = endCoords.pageY - startCoords.pageY;\n            vDistancePercent = (vDistance * 100) / winHeight;\n\n            let opacity;\n            if (vSwipe && mediaImage) {\n                opacity = 1 - Math.abs(vDistance) / winHeight;\n                overlay.style.opacity = opacity;\n\n                if (instance.settings.touchFollowAxis) {\n                    hDistancePercent = 0;\n                }\n            }\n            if (hSwipe) {\n                opacity = 1 - Math.abs(hDistance) / winWidth;\n                media.style.opacity = opacity;\n\n                if (instance.settings.touchFollowAxis) {\n                    vDistancePercent = 0;\n                }\n            }\n\n            if (!mediaImage) {\n                return cssTransform(media, `translate3d(${hDistancePercent}%, 0, 0)`);\n            }\n\n            cssTransform(media, `translate3d(${hDistancePercent}%, ${vDistancePercent}%, 0)`);\n        },\n        touchEnd: () => {\n            if (!process) {\n                return;\n            }\n            doingMove = false;\n            if (imageZoomed || doingZoom) {\n                lastZoomedPosX = zoomedPosX;\n                lastZoomedPosY = zoomedPosY;\n                return;\n            }\n            const v = Math.abs(parseInt(vDistancePercent));\n            const h = Math.abs(parseInt(hDistancePercent));\n\n            if (v > 29 && mediaImage) {\n                instance.close();\n                return;\n            }\n            if (v < 29 && h < 25) {\n                addClass(overlay, 'greset');\n                overlay.style.opacity = 1;\n                return resetSlideMove(media);\n            }\n        },\n        multipointEnd: () => {\n            setTimeout(() => {\n                doingZoom = false;\n            }, 50);\n        },\n        multipointStart: () => {\n            doingZoom = true;\n            initScale = currentScale ? currentScale : 1;\n        },\n        pinch: (evt) => {\n            if (!mediaImage || doingMove) {\n                return false;\n            }\n\n            doingZoom = true;\n            mediaImage.scaleX = mediaImage.scaleY = initScale * evt.zoom;\n\n            let scale = initScale * evt.zoom;\n            imageZoomed = true;\n\n            if (scale <= 1) {\n                imageZoomed = false;\n                scale = 1;\n                lastZoomedPosY = null;\n                lastZoomedPosX = null;\n                zoomedPosX = null;\n                zoomedPosY = null;\n                mediaImage.setAttribute('style', '');\n                return;\n            }\n            if (scale > maxScale) {\n                // max scale zoom\n                scale = maxScale;\n            }\n\n            mediaImage.style.transform = `scale3d(${scale}, ${scale}, 1)`;\n            currentScale = scale;\n        },\n        pressMove: (e) => {\n            if (imageZoomed && !doingZoom) {\n                var mhDistance = endCoords.pageX - startCoords.pageX;\n                var mvDistance = endCoords.pageY - startCoords.pageY;\n\n                if (lastZoomedPosX) {\n                    mhDistance = mhDistance + lastZoomedPosX;\n                }\n                if (lastZoomedPosY) {\n                    mvDistance = mvDistance + lastZoomedPosY;\n                }\n\n                zoomedPosX = mhDistance;\n                zoomedPosY = mvDistance;\n\n                let style = `translate3d(${mhDistance}px, ${mvDistance}px, 0)`;\n                if (currentScale) {\n                    style += ` scale3d(${currentScale}, ${currentScale}, 1)`;\n                }\n                cssTransform(mediaImage, style);\n            }\n        },\n        swipe: (evt) => {\n            if (imageZoomed) {\n                return;\n            }\n            if (doingZoom) {\n                doingZoom = false;\n                return;\n            }\n            if (evt.direction == 'Left') {\n                if (instance.index == instance.elements.length - 1) {\n                    return resetSlideMove(media);\n                }\n                instance.nextSlide();\n            }\n            if (evt.direction == 'Right') {\n                if (instance.index == 0) {\n                    return resetSlideMove(media);\n                }\n                instance.prevSlide();\n            }\n        }\n    });\n\n    instance.events['touch'] = touchInstance;\n}\n","function getLen(v) {\n    return Math.sqrt(v.x * v.x + v.y * v.y);\n}\n\nfunction dot(v1, v2) {\n    return v1.x * v2.x + v1.y * v2.y;\n}\n\nfunction getAngle(v1, v2) {\n    var mr = getLen(v1) * getLen(v2);\n    if (mr === 0) {\n        return 0;\n    }\n    var r = dot(v1, v2) / mr;\n    if (r > 1) {\n        r = 1;\n    }\n    return Math.acos(r);\n}\n\nfunction cross(v1, v2) {\n    return v1.x * v2.y - v2.x * v1.y;\n}\n\nfunction getRotateAngle(v1, v2) {\n    var angle = getAngle(v1, v2);\n    if (cross(v1, v2) > 0) {\n        angle *= -1;\n    }\n\n    return (angle * 180) / Math.PI;\n}\n\nclass EventsHandlerAdmin {\n    constructor(el) {\n        this.handlers = [];\n        this.el = el;\n    }\n    add(handler) {\n        this.handlers.push(handler);\n    }\n    del(handler) {\n        if (!handler) {\n            this.handlers = [];\n        }\n\n        for (var i = this.handlers.length; i >= 0; i--) {\n            if (this.handlers[i] === handler) {\n                this.handlers.splice(i, 1);\n            }\n        }\n    }\n    dispatch() {\n        for (var i = 0, len = this.handlers.length; i < len; i++) {\n            var handler = this.handlers[i];\n            if (typeof handler === 'function') {\n                handler.apply(this.el, arguments);\n            }\n        }\n    }\n}\n\nfunction wrapFunc(el, handler) {\n    var EventshandlerAdmin = new EventsHandlerAdmin(el);\n    EventshandlerAdmin.add(handler);\n\n    return EventshandlerAdmin;\n}\n\n// Modified version of AlloyFinger\nexport default class TouchEvents {\n    constructor(el, option) {\n        this.element = typeof el == 'string' ? document.querySelector(el) : el;\n\n        this.start = this.start.bind(this);\n        this.move = this.move.bind(this);\n        this.end = this.end.bind(this);\n        this.cancel = this.cancel.bind(this);\n        this.element.addEventListener('touchstart', this.start, false);\n        this.element.addEventListener('touchmove', this.move, false);\n        this.element.addEventListener('touchend', this.end, false);\n        this.element.addEventListener('touchcancel', this.cancel, false);\n\n        this.preV = { x: null, y: null };\n        this.pinchStartLen = null;\n        this.zoom = 1;\n        this.isDoubleTap = false;\n\n        var noop = function () {};\n\n        this.rotate = wrapFunc(this.element, option.rotate || noop);\n        this.touchStart = wrapFunc(this.element, option.touchStart || noop);\n        this.multipointStart = wrapFunc(this.element, option.multipointStart || noop);\n        this.multipointEnd = wrapFunc(this.element, option.multipointEnd || noop);\n        this.pinch = wrapFunc(this.element, option.pinch || noop);\n        this.swipe = wrapFunc(this.element, option.swipe || noop);\n        this.tap = wrapFunc(this.element, option.tap || noop);\n        this.doubleTap = wrapFunc(this.element, option.doubleTap || noop);\n        this.longTap = wrapFunc(this.element, option.longTap || noop);\n        this.singleTap = wrapFunc(this.element, option.singleTap || noop);\n        this.pressMove = wrapFunc(this.element, option.pressMove || noop);\n        this.twoFingerPressMove = wrapFunc(this.element, option.twoFingerPressMove || noop);\n        this.touchMove = wrapFunc(this.element, option.touchMove || noop);\n        this.touchEnd = wrapFunc(this.element, option.touchEnd || noop);\n        this.touchCancel = wrapFunc(this.element, option.touchCancel || noop);\n        this.translateContainer = this.element;\n\n        this._cancelAllHandler = this.cancelAll.bind(this);\n\n        window.addEventListener('scroll', this._cancelAllHandler);\n\n        this.delta = null;\n        this.last = null;\n        this.now = null;\n        this.tapTimeout = null;\n        this.singleTapTimeout = null;\n        this.longTapTimeout = null;\n        this.swipeTimeout = null;\n        this.x1 = this.x2 = this.y1 = this.y2 = null;\n        this.preTapPosition = { x: null, y: null };\n    }\n    start(evt) {\n        if (!evt.touches) {\n            return;\n        }\n\n        // Fix Media Buttons Not responding on Android #233\n        const ignoreDragFor = ['a', 'button', 'input'];\n        if (evt.target && evt.target.nodeName && ignoreDragFor.indexOf(evt.target.nodeName.toLowerCase()) >= 0) {\n            console.log('ignore drag for this touched element', evt.target.nodeName.toLowerCase());\n            return;\n        }\n\n        this.now = Date.now();\n        this.x1 = evt.touches[0].pageX;\n        this.y1 = evt.touches[0].pageY;\n        this.delta = this.now - (this.last || this.now);\n        this.touchStart.dispatch(evt, this.element);\n        if (this.preTapPosition.x !== null) {\n            this.isDoubleTap = this.delta > 0 && this.delta <= 250 && Math.abs(this.preTapPosition.x - this.x1) < 30 && Math.abs(this.preTapPosition.y - this.y1) < 30;\n            if (this.isDoubleTap) {\n                clearTimeout(this.singleTapTimeout);\n            }\n        }\n        this.preTapPosition.x = this.x1;\n        this.preTapPosition.y = this.y1;\n        this.last = this.now;\n        var preV = this.preV,\n            len = evt.touches.length;\n        if (len > 1) {\n            this._cancelLongTap();\n            this._cancelSingleTap();\n            var v = { x: evt.touches[1].pageX - this.x1, y: evt.touches[1].pageY - this.y1 };\n            preV.x = v.x;\n            preV.y = v.y;\n            this.pinchStartLen = getLen(preV);\n            this.multipointStart.dispatch(evt, this.element);\n        }\n        this._preventTap = false;\n        this.longTapTimeout = setTimeout(\n            function () {\n                this.longTap.dispatch(evt, this.element);\n                this._preventTap = true;\n            }.bind(this),\n            750\n        );\n    }\n    move(evt) {\n        if (!evt.touches) {\n            return;\n        }\n        var preV = this.preV,\n            len = evt.touches.length,\n            currentX = evt.touches[0].pageX,\n            currentY = evt.touches[0].pageY;\n        this.isDoubleTap = false;\n        if (len > 1) {\n            var sCurrentX = evt.touches[1].pageX,\n                sCurrentY = evt.touches[1].pageY;\n            var v = { x: evt.touches[1].pageX - currentX, y: evt.touches[1].pageY - currentY };\n\n            if (preV.x !== null) {\n                if (this.pinchStartLen > 0) {\n                    evt.zoom = getLen(v) / this.pinchStartLen;\n                    this.pinch.dispatch(evt, this.element);\n                }\n\n                evt.angle = getRotateAngle(v, preV);\n                this.rotate.dispatch(evt, this.element);\n            }\n            preV.x = v.x;\n            preV.y = v.y;\n\n            if (this.x2 !== null && this.sx2 !== null) {\n                evt.deltaX = (currentX - this.x2 + sCurrentX - this.sx2) / 2;\n                evt.deltaY = (currentY - this.y2 + sCurrentY - this.sy2) / 2;\n            } else {\n                evt.deltaX = 0;\n                evt.deltaY = 0;\n            }\n            this.twoFingerPressMove.dispatch(evt, this.element);\n\n            this.sx2 = sCurrentX;\n            this.sy2 = sCurrentY;\n        } else {\n            if (this.x2 !== null) {\n                evt.deltaX = currentX - this.x2;\n                evt.deltaY = currentY - this.y2;\n\n                var movedX = Math.abs(this.x1 - this.x2),\n                    movedY = Math.abs(this.y1 - this.y2);\n\n                if (movedX > 10 || movedY > 10) {\n                    this._preventTap = true;\n                }\n            } else {\n                evt.deltaX = 0;\n                evt.deltaY = 0;\n            }\n            this.pressMove.dispatch(evt, this.element);\n        }\n\n        this.touchMove.dispatch(evt, this.element);\n\n        this._cancelLongTap();\n        this.x2 = currentX;\n        this.y2 = currentY;\n\n        if (len > 1) {\n            evt.preventDefault();\n        }\n    }\n    end(evt) {\n        if (!evt.changedTouches) {\n            return;\n        }\n        this._cancelLongTap();\n        var self = this;\n        if (evt.touches.length < 2) {\n            this.multipointEnd.dispatch(evt, this.element);\n            this.sx2 = this.sy2 = null;\n        }\n\n        //swipe\n        if ((this.x2 && Math.abs(this.x1 - this.x2) > 30) || (this.y2 && Math.abs(this.y1 - this.y2) > 30)) {\n            evt.direction = this._swipeDirection(this.x1, this.x2, this.y1, this.y2);\n            this.swipeTimeout = setTimeout(function () {\n                self.swipe.dispatch(evt, self.element);\n            }, 0);\n        } else {\n            this.tapTimeout = setTimeout(function () {\n                if (!self._preventTap) {\n                    self.tap.dispatch(evt, self.element);\n                }\n                // trigger double tap immediately\n                if (self.isDoubleTap) {\n                    self.doubleTap.dispatch(evt, self.element);\n                    self.isDoubleTap = false;\n                }\n            }, 0);\n\n            if (!self.isDoubleTap) {\n                self.singleTapTimeout = setTimeout(function () {\n                    self.singleTap.dispatch(evt, self.element);\n                }, 250);\n            }\n        }\n\n        this.touchEnd.dispatch(evt, this.element);\n\n        this.preV.x = 0;\n        this.preV.y = 0;\n        this.zoom = 1;\n        this.pinchStartLen = null;\n        this.x1 = this.x2 = this.y1 = this.y2 = null;\n    }\n    cancelAll() {\n        this._preventTap = true;\n        clearTimeout(this.singleTapTimeout);\n        clearTimeout(this.tapTimeout);\n        clearTimeout(this.longTapTimeout);\n        clearTimeout(this.swipeTimeout);\n    }\n    cancel(evt) {\n        this.cancelAll();\n        this.touchCancel.dispatch(evt, this.element);\n    }\n    _cancelLongTap() {\n        clearTimeout(this.longTapTimeout);\n    }\n    _cancelSingleTap() {\n        clearTimeout(this.singleTapTimeout);\n    }\n    _swipeDirection(x1, x2, y1, y2) {\n        return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ? (x1 - x2 > 0 ? 'Left' : 'Right') : y1 - y2 > 0 ? 'Up' : 'Down';\n    }\n    on(evt, handler) {\n        if (this[evt]) {\n            this[evt].add(handler);\n        }\n    }\n    off(evt, handler) {\n        if (this[evt]) {\n            this[evt].del(handler);\n        }\n    }\n    destroy() {\n        if (this.singleTapTimeout) {\n            clearTimeout(this.singleTapTimeout);\n        }\n        if (this.tapTimeout) {\n            clearTimeout(this.tapTimeout);\n        }\n        if (this.longTapTimeout) {\n            clearTimeout(this.longTapTimeout);\n        }\n        if (this.swipeTimeout) {\n            clearTimeout(this.swipeTimeout);\n        }\n\n        this.element.removeEventListener('touchstart', this.start);\n        this.element.removeEventListener('touchmove', this.move);\n        this.element.removeEventListener('touchend', this.end);\n        this.element.removeEventListener('touchcancel', this.cancel);\n\n        this.rotate.del();\n        this.touchStart.del();\n        this.multipointStart.del();\n        this.multipointEnd.del();\n        this.pinch.del();\n        this.swipe.del();\n        this.tap.del();\n        this.doubleTap.del();\n        this.longTap.del();\n        this.singleTap.del();\n        this.pressMove.del();\n        this.twoFingerPressMove.del();\n        this.touchMove.del();\n        this.touchEnd.del();\n        this.touchCancel.del();\n\n        this.preV =\n            this.pinchStartLen =\n            this.zoom =\n            this.isDoubleTap =\n            this.delta =\n            this.last =\n            this.now =\n            this.tapTimeout =\n            this.singleTapTimeout =\n            this.longTapTimeout =\n            this.swipeTimeout =\n            this.x1 =\n            this.x2 =\n            this.y1 =\n            this.y2 =\n            this.preTapPosition =\n            this.rotate =\n            this.touchStart =\n            this.multipointStart =\n            this.multipointEnd =\n            this.pinch =\n            this.swipe =\n            this.tap =\n            this.doubleTap =\n            this.longTap =\n            this.singleTap =\n            this.pressMove =\n            this.touchMove =\n            this.touchEnd =\n            this.touchCancel =\n            this.twoFingerPressMove =\n                null;\n\n        window.removeEventListener('scroll', this._cancelAllHandler);\n        return null;\n    }\n}\n"],"names":["$d8642219fb19b896$export$d0a8044dce8ff2fc","window","navigator","userAgent","match","Date","now","document","undefined","createTouch","msMaxTouchPoints","getElementsByTagName","$81a53f2a460b34f6$var$defaults","selector","elements","skin","theme","closeButton","startAt","autoplayVideos","autofocusVideos","descPosition","width","height","videosWidth","beforeSlideChange","afterSlideChange","beforeSlideLoad","afterSlideLoad","slideInserted","slideRemoved","slideExtraAttributes","onOpen","onClose","loop","zoomable","draggable","dragAutoSnap","dragToleranceX","dragToleranceY","preload","oneSlidePerOpen","touchNavigation","touchFollowAxis","keyboardNavigation","closeOnOutsideClick","plugins","plyr","css","js","config","ratio","fullscreen","enabled","iosNative","youtube","noCookie","rel","showinfo","iv_load_policy","vimeo","byline","portrait","title","transparent","openEffect","closeEffect","slideEffect","moreText","moreLength","cssEfects","fade","in","out","zoom","slide","slideBack","none","svg","close","next","prev","slideHTML","lightboxHTML"],"version":3,"file":"index.8e09efe2.js.map"}